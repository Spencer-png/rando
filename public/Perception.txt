Engine
Core functions for script lifecycle, logging, and user information.

engine.register_onunload
Signature: engine.register_onunload(callback)

Description: Registers a function to be called when the script is unloaded.

Parameters:

callback (function): The function to be called when the script is unloaded.

Returns: None

Example:

Copy
-- Register a cleanup function to be called when the script is unloaded
function on_unload_callback()
    engine.log("Script is being unloaded", 255, 255, 255, 255)
    -- Perform any necessary cleanup operations here
end

-- Register the callback with the engine
engine.register_onunload(on_unload_callback)
This function is useful for cleanup operations when your script is being unloaded, such as freeing allocated resources, closing file handles, or saving state.

engine.register_on_engine_tick
Signature: engine.register_on_engine_tick(callback)

Description: Registers a function to be called every engine tick. This is useful for implementing continuous operations or monitoring.

Parameters:

callback (function): The function to be called on every engine tick.

Returns: None

Example:

Copy
-- Callback function that will execute on every engine tick
function enginetick_callback()
    -- Your logic here (executed on every engine tick)
    -- For example, checking game state, updating UI, etc.
    local fps = render.get_fps()
    if fps < 30 then
        engine.log("Low FPS detected: " .. fps, 255, 0, 0, 255)
    end
end

-- Register the callback with the engine
engine.register_on_engine_tick(enginetick_callback)
This function should be used for operations that need to be performed continuously, such as monitoring game state, updating UI elements, or performing animations.

engine.register_on_network_callback
Signature: engine.register_on_network_callback(callback)

Description: Registers a function to handle network responses from HTTP requests made with net.send_request().

Parameters:

callback (function): The function to be called when a network response is received. The callback should accept two parameters: response_data (buffer handle) and url (string).

Returns: None

Example:

Copy
-- Callback function to handle network responses
function network_callback(response_data, url)
    -- Read the response data from the buffer
    local response_text = m.read_string(response_data, 0)
    
    -- Log the response
    engine.log("Received response from: " .. url, 0, 255, 0, 255)
    engine.log("Response: " .. response_text, 255, 255, 255, 255)
    
    -- You can also write the response to a file
    fs.write_to_file_from_buffer("response.txt", response_data)
end

-- Register the network callback
engine.register_on_network_callback(network_callback)

-- Make an HTTP request (the response will be handled by the callback)
net.send_request("https://example.com/api", "User-Agent: MyScript/1.0", nil)
This function is essential for handling asynchronous network responses in your scripts. The response data is provided as a memory buffer that you can read using the appropriate memory functions.

engine.log
Signature: engine.log(message, r, g, b, a)

Description: Logs a message to the console with the specified RGBA color.

Parameters:

message (string): The message to log.

r (number): Red color component (0-255).

g (number): Green color component (0-255).

b (number): Blue color component (0-255).

a (number): Alpha (transparency) component (0-255).

Returns: None

Example:

Copy
-- Log a white message
engine.log("This is a white message", 255, 255, 255, 255)

-- Log an error in red
engine.log("Error: Something went wrong!", 255, 0, 0, 255)

-- Log a success message in green
engine.log("Success: Operation completed", 0, 255, 0, 255)

-- Log a warning message in yellow
engine.log("Warning: Proceed with caution", 255, 255, 0, 255)

-- Log a debug message in blue
engine.log("Debug: x = " .. tostring(x), 0, 0, 255, 255)
This function is commonly used for debugging, displaying status messages, and providing feedback to the user.

engine.get_username
Signature: engine.get_username()

Description: Returns the username of the currently logged-in user.

Parameters: None

Returns:

string: The username of the currently logged-in user.

Example:

Copy
-- Get the current username
local username = engine.get_username()
engine.log("Hello, " .. username .. "!", 255, 255, 255, 255)
This function is useful for personalizing messages or identifying the current user in logs or saved files.

Filesystem
Functions for reading, writing, deleting, and managing local files and buffers.

fs.does_file_exist
Signature: fs.does_file_exist(file_name)

Description: Checks if a file exists at the specified path.

Parameters:

file_name (string): The path of the file to check.

Returns:

boolean: true if the file exists, false otherwise.

Example:

Copy
-- Check if a configuration file exists
local config_file = "settings.json"
if fs.does_file_exist(config_file) then
    engine.log("Config file found!", 0, 255, 0, 255)
    -- Load the configuration
    local config_data = fs.read_from_file(config_file)
    -- Process config_data...
else
    engine.log("Config file not found, creating default...", 255, 255, 0, 255)
    -- Create a default configuration file
    fs.write_to_file(config_file, "{ \"setting1\": true, \"setting2\": 100 }")
end
fs.read_from_file
Signature: fs.read_from_file(file_name)

Description: Reads data from a file as a string.

Parameters:

file_name (string): The path of the file to read.

Returns:

string: The contents of the file as a string, or nil if the file cannot be read.

Example:

Copy
-- Read data from a text file
function load_text_file(file_path)
    if not fs.does_file_exist(file_path) then
        engine.log("Error: File does not exist: " .. file_path, 255, 0, 0, 255)
        return nil
    end
    
    local data = fs.read_from_file(file_path)
    if data then
        engine.log("Successfully read " .. #data .. " bytes from " .. file_path, 0, 255, 0, 255)
        return data
    else
        engine.log("Error: Failed to read file: " .. file_path, 255, 0, 0, 255)
        return nil
    end
end

-- Usage example
local log_content = load_text_file("logs/app.log")
if log_content then
    -- Process log content
    local line_count = select(2, string.gsub(log_content, "\n", "")) + 1
    engine.log("Log file contains " .. line_count .. " lines", 255, 255, 255, 255)
end
fs.write_to_file
Signature: fs.write_to_file(file_name, data)

Description: Writes data to a file as a string. If the file already exists, it will be overwritten.

Parameters:

file_name (string): The path of the file to write.

data (string): The data to write to the file.

Returns:

boolean: true if the write operation was successful, false otherwise.

Example:

Copy
-- Save application settings to a file
function save_settings(settings_table)
    -- Convert the settings table to a JSON string
    local settings_json = json.stringify(settings_table)
    
    -- Write to the settings file
    local success = fs.write_to_file("settings.json", settings_json)
    
    if success then
        engine.log("Settings saved successfully", 0, 255, 0, 255)
    else
        engine.log("Failed to save settings", 255, 0, 0, 255)
    end
    
    return success
end

-- Usage example
local settings = {
    volume = 75,
    fullscreen = true,
    resolution = "1920x1080",
    username = engine.get_username()
}

save_settings(settings)
fs.delete_file
Signature: fs.delete_file(file_name)

Description: Deletes the specified file.

Parameters:

file_name (string): The path of the file to delete.

Returns:

boolean: true if the file was successfully deleted, false otherwise.

Example:

Copy
-- Delete a temporary file
function cleanup_temp_file(temp_file_path)
    if fs.does_file_exist(temp_file_path) then
        local success = fs.delete_file(temp_file_path)
        
        if success then
            engine.log("Temporary file deleted: " .. temp_file_path, 0, 255, 0, 255)
        else
            engine.log("Failed to delete temporary file: " .. temp_file_path, 255, 0, 0, 255)
        end
        
        return success
    else
        engine.log("Temporary file does not exist: " .. temp_file_path, 255, 255, 0, 255)
        return true  -- Consider it a success if the file doesn't exist
    end
end

-- Usage example
cleanup_temp_file("temp/cache.dat")
fs.write_to_file_from_buffer
Signature: fs.write_to_file_from_buffer(file_name, buffer_handle)

Description: Writes all contents of a memory buffer to a file.

Parameters:

file_name (string): The path of the file to write.

buffer_handle (handle): A handle to the memory buffer containing the data to write.

Returns:

boolean: true if the write operation was successful, false otherwise.

Example:

Copy
-- Download and save an image file
function download_and_save_image(url, save_path)
    -- Register a callback for when the network response is received
    engine.register_on_network_callback(function(response_data, response_url)
        if response_url == url then
            -- Write the response buffer directly to a file
            local success = fs.write_to_file_from_buffer(save_path, response_data)
            
            if success then
                engine.log("Image downloaded and saved to: " .. save_path, 0, 255, 0, 255)
            else
                engine.log("Failed to save image to: " .. save_path, 255, 0, 0, 255)
            end
        end
    end)
    
    -- Send the HTTP request to download the image
    net.send_request(url, "User-Agent: MyApp/1.0", nil)
    engine.log("Downloading image from: " .. url, 255, 255, 255, 255)
end

-- Usage example
download_and_save_image("https://example.com/image.jpg", "downloads/image.jpg")
fs.read_from_file_to_buffer
Signature: fs.read_from_file_to_buffer(file_name, buffer_handle)

Description: Reads all file contents into a memory buffer.

Parameters:

file_name (string): The path of the file to read.

buffer_handle (handle): A handle to the memory buffer where the file contents will be stored.

Returns:

boolean: true if the read operation was successful, false otherwise.

Example:

Copy
-- Read an image file into a buffer and create a bitmap from it
function load_image_to_buffer(image_path)
    if not fs.does_file_exist(image_path) then
        engine.log("Image file does not exist: " .. image_path, 255, 0, 0, 255)
        return nil
    end
    
    -- Get the file size to allocate the correct buffer size
    local file_size = fs.get_file_size(image_path)
    if file_size <= 0 then
        engine.log("Invalid file size for: " .. image_path, 255, 0, 0, 255)
        return nil
    end
    
    -- Allocate a buffer to hold the file contents
    local buffer = m.alloc(file_size)
    if not buffer then
        engine.log("Failed to allocate buffer for file: " .. image_path, 255, 0, 0, 255)
        return nil
    end
    
    -- Read the file into the buffer
    local success = fs.read_from_file_to_buffer(image_path, buffer)
    if not success then
        engine.log("Failed to read file into buffer: " .. image_path, 255, 0, 0, 255)
        m.free(buffer)
        return nil
    end
    
    engine.log("Successfully loaded " .. file_size .. " bytes from " .. image_path, 0, 255, 0, 255)
    return buffer
end

-- Usage example
local image_buffer = load_image_to_buffer("images/texture.png")
if image_buffer then
    -- Create a bitmap from the buffer for rendering
    local bitmap = render.create_bitmap_from_buffer(image_buffer)
    
    -- Clean up the buffer when done
    m.free(image_buffer)
end
fs.get_file_size
Signature: fs.get_file_size(file_name)

Description: Gets the size of a file in bytes.

Parameters:

file_name (string): The path of the file.

Returns:

number: The size of the file in bytes, or 0 if the file does not exist or cannot be accessed.

Example:

Copy
-- Check if a file is empty or exceeds a size limit
function check_file_size(file_path, size_limit)
    if not fs.does_file_exist(file_path) then
        engine.log("File does not exist: " .. file_path, 255, 0, 0, 255)
        return false
    end
    
    local file_size = fs.get_file_size(file_path)
    
    if file_size == 0 then
        engine.log("File is empty: " .. file_path, 255, 255, 0, 255)
        return false
    end
    
    if size_limit and file_size > size_limit then
        engine.log("File exceeds size limit (" .. file_size .. " bytes): " .. file_path, 255, 0, 0, 255)
        return false
    end
    
    engine.log("File size: " .. file_size .. " bytes", 0, 255, 0, 255)
    return true
end

-- Usage example
check_file_size("data/large_file.dat", 1024 * 1024)  -- Check if file is under 1 MB
fs.compress
Signature: fs.compress(string)

Description: Compresses a Lua string using a compression algorithm.

Parameters:

string (string): The string data to compress.

Returns:

string: The compressed data as a string, or nil if compression failed.

Example:

Copy
-- Compress and save a large text document
function compress_and_save_text(text, file_path)
    -- Compress the text
    local compressed_data = fs.compress(text)
    
    if not compressed_data then
        engine.log("Compression failed", 255, 0, 0, 255)
        return false
    end
    
    -- Log compression ratio
    local original_size = #text
    local compressed_size = #compressed_data
    local ratio = math.floor((compressed_size / original_size) * 100)
    
    engine.log("Compressed " .. original_size .. " bytes to " .. compressed_size .. 
        " bytes (" .. ratio .. "% of original size)", 0, 255, 0, 255)
    
    -- Save the compressed data to a file
    return fs.write_to_file(file_path, compressed_data)
end

-- Usage example
local large_text = "..." -- Imagine a very large string here
compress_and_save_text(large_text, "data/document.compressed")
fs.decompress
Signature: fs.decompress(string)

Description: Decompresses a previously compressed string.

Parameters:

string (string): The compressed data string.

Returns:

string: The decompressed data as a string, or nil if decompression failed.

Example:

Copy
-- Load and decompress a saved file
function load_and_decompress(file_path)
    if not fs.does_file_exist(file_path) then
        engine.log("Compressed file not found: " .. file_path, 255, 0, 0, 255)
        return nil
    end
    
    -- Read the compressed data
    local compressed_data = fs.read_from_file(file_path)
    if not compressed_data then
        engine.log("Failed to read compressed file: " .. file_path, 255, 0, 0, 255)
        return nil
    end
    
    -- Decompress the data
    local decompressed_data = fs.decompress(compressed_data)
    if not decompressed_data then
        engine.log("Decompression failed for file: " .. file_path, 255, 0, 0, 255)
        return nil
    end
    
    engine.log("Successfully decompressed data from: " .. file_path, 0, 255, 0, 255)
    return decompressed_data
end

-- Usage example
local document_text = load_and_decompress("data/document.compressed")
if document_text then
    -- Process the decompressed text
    engine.log("Decompressed document size: " .. #document_text .. " bytes", 255, 255, 255, 255)
end
Input
Keyboard, mouse, and clipboard input detection and simulation.

input.simulate_mouse
Signature: input.simulate_mouse(dx, dy, flag)

Description: Simulates mouse input using location or flags.

Parameters:

dx (number): Horizontal movement delta in pixels

dy (number): Vertical movement delta in pixels

flag (number): Mouse event flag (0: move, 1: left down, 2: left up, 4: right down, 8: right up)

Returns: None

Example:

Copy
-- Simulate mouse movement
input.simulate_mouse(5, 3, 0)  -- Move 5 pixels right, 3 pixels down

-- Simulate left mouse click (down and up)
input.simulate_mouse(0, 0, 1)  -- Left button down
engine.delay(16, function()
    input.simulate_mouse(0, 0, 2)  -- Left button up
end)

-- Simulate right mouse click at current position
input.simulate_mouse(0, 0, 4)  -- Right button down
engine.delay(16, function()
    input.simulate_mouse(0, 0, 8)  -- Right button up
end)
input.simulate_keyboard
Signature: input.simulate_keyboard(key, flag)

Description: Simulates keyboard input using virtual key codes and flags.

Parameters:

key (number): Virtual key code to simulate

flag (number): Keyboard event flag (1: key down, 2: key up)

Returns: None

Example:

Copy
-- Simulate pressing and releasing the 'A' key (Virtual key code 65)
input.simulate_keyboard(65, 1)  -- Key down
engine.delay(16, function()
    input.simulate_keyboard(65, 2)  -- Key up
end)

-- Simulate pressing Enter (Virtual key code 13)
input.simulate_keyboard(13, 1)  -- Key down
engine.delay(16, function()
    input.simulate_keyboard(13, 2)  -- Key up
end)
input.is_key_pressed
Signature: input.is_key_pressed(key)

Description: Detects if a key is pressed once (triggers only on the initial press).

Parameters:

key (number): Virtual key code to check.

Returns:

boolean: true if the key was just pressed, false otherwise.

Example:

Copy
-- Check if the spacebar (key code 32) was just pressed
function check_spacebar()
    if input.is_key_pressed(32) then
        engine.log("Spacebar was just pressed!", 255, 255, 255, 255)
        -- Execute action once on press
    end
end

engine.register_on_engine_tick(check_spacebar)
input.is_key_down
Signature: input.is_key_down(key)

Description: Detects if a key is being held down continuously.

Parameters:

key (number): Virtual key code to check.

Returns:

boolean: true if the key is being held down, false otherwise.

Example:

Copy
-- Check if the Ctrl key (key code 17) is being held down
function check_ctrl_key()
    if input.is_key_down(17) then
        engine.log("Ctrl key is being held down", 255, 255, 255, 255)
        -- Execute continuous action while key is down
    end
end

engine.register_on_engine_tick(check_ctrl_key)
input.is_key_toggled
Signature: input.is_key_toggled(key)

Description: Checks if a key's toggle state is active (useful for keys like Caps Lock).

Parameters:

key (number): Virtual key code to check.

Returns:

boolean: true if the key's toggle state is active, false otherwise.

Example:

Copy
-- Check if Caps Lock (key code 20) is toggled on
function check_caps_lock()
    if input.is_key_toggled(20) then
        engine.log("Caps Lock is toggled on", 255, 255, 255, 255)
        -- Perform action based on Caps Lock state
    else
        engine.log("Caps Lock is toggled off", 255, 255, 255, 255)
    end
end

engine.register_on_engine_tick(check_caps_lock)
input.get_mouse_position
Signature: input.get_mouse_position()

Description: Returns the current mouse cursor position.

Parameters: None

Returns:

x (number): The x-coordinate of the mouse cursor.

y (number): The y-coordinate of the mouse cursor.

Example:

Copy
-- Get the current mouse position
function track_mouse_position()
    local x, y = input.get_mouse_position()
    engine.log("Mouse Position: " .. x .. ", " .. y, 255, 255, 255, 255)
    
    -- Use position for cursor-based features
    if x < 100 and y < 100 then
        -- Mouse is in the top-left corner
        engine.log("Mouse in top-left corner", 255, 255, 0, 255)
    end
end

engine.register_on_engine_tick(track_mouse_position)
input.get_mouse_move_delta
Signature: input.get_mouse_move_delta()

Description: Returns the mouse movement delta (change) since the last tick.

Parameters: None

Returns:

dx (number): The change in x-coordinate since the last tick.

dy (number): The change in y-coordinate since the last tick.

Example:

Copy
-- Track mouse movement delta
function track_mouse_movement()
    local dx, dy = input.get_mouse_move_delta()
    
    if dx ~= 0 or dy ~= 0 then
        engine.log("Mouse Movement Delta: " .. dx .. ", " .. dy, 255, 255, 255, 255)
        
        -- Detect quick movements
        local movement_distance = math.sqrt(dx*dx + dy*dy)
        if movement_distance > 50 then
            engine.log("Fast mouse movement detected!", 255, 0, 0, 255)
        end
    end
end

engine.register_on_engine_tick(track_mouse_movement)
input.get_scroll_delta
Signature: input.get_scroll_delta()

Description: Returns the mouse scroll wheel delta since the last tick.

Parameters: None

Returns:

number: The scroll wheel delta (positive for scrolling up, negative for scrolling down).

Example:

Copy
-- Track mouse scroll wheel
function track_scroll_wheel()
    local scroll_delta = input.get_scroll_delta()
    
    if scroll_delta ~= 0 then
        if scroll_delta > 0 then
            engine.log("Scrolled up: " .. scroll_delta, 0, 255, 0, 255)
            -- Perform scroll up action
        else
            engine.log("Scrolled down: " .. scroll_delta, 255, 0, 0, 255)
            -- Perform scroll down action
        end
    end
end

engine.register_on_engine_tick(track_scroll_wheel)
input.get_clipboard
Signature: input.get_clipboard()

Description: Gets the current text content of the system clipboard.

Parameters: None

Returns:

string: The text content of the clipboard.

Example:

Copy
-- Read clipboard content
function read_clipboard()
    local clipboard_text = input.get_clipboard()
    
    if clipboard_text and clipboard_text ~= "" then
        engine.log("Clipboard content: " .. clipboard_text, 255, 255, 255, 255)
        
        -- Process clipboard data
        if clipboard_text:match("^https?://") then
            engine.log("URL detected in clipboard!", 0, 255, 0, 255)
            -- Process URL
        end
    end
end

-- Check clipboard when a key is pressed
function clipboard_check_on_key()
    if input.is_key_pressed(86) and input.is_key_down(17) then  -- Ctrl+V
        read_clipboard()
    end
end

engine.register_on_engine_tick(clipboard_check_on_key)
input.set_clipboard
Signature: input.set_clipboard(text)

Description: Sets new text content to the system clipboard.

Parameters:

text (string): The text to set to the clipboard.

Returns: None

Example:

Copy
-- Copy text to clipboard
function copy_to_clipboard(text)
    input.set_clipboard(text)
    engine.log("Copied to clipboard: " .. text, 0, 255, 0, 255)
end

-- Example usage: Copy coordinates
function copy_coordinates()
    if input.is_key_pressed(67) and input.is_key_down(17) then  -- Ctrl+C
        local x, y = input.get_mouse_position()
        local coords_text = string.format("X: %d, Y: %d", x, y)
        copy_to_clipboard(coords_text)
    end
end

engine.register_on_engine_tick(copy_coordinates)
input.is_menu_open
Signature: input.is_menu_open()

Description: Checks if the menu is currently open.

Parameters: None

Returns:

boolean: true if the menu is open, false otherwise.

Example:

Copy
-- Check menu state
function check_menu_state()
    if input.is_menu_open() then
        -- Menu is open, disable certain features
        engine.log("Menu is open - some features disabled", 255, 255, 0, 255)
    else
        -- Menu is closed, enable all features
        engine.log("Menu is closed - all features enabled", 0, 255, 0, 255)
    end
end

engine.register_on_engine_tick(check_menu_state)
input.set_overlay_force_cursor_active
Signature: input.set_overlay_force_cursor_active(state)

Description: Forces the overlay cursor to be active or inactive.

Parameters:

state (boolean): true to force the cursor active, false to allow normal behavior.

Returns: None

Example:

Copy
-- Force cursor to be visible when a key is held
function manage_cursor_visibility()
    if input.is_key_down(16) then  -- Shift key
        -- Force cursor to be visible while shift is held
        input.set_overlay_force_cursor_active(true)
    else
        -- Return to normal cursor behavior
        input.set_overlay_force_cursor_active(false)
    end
end

engine.register_on_engine_tick(manage_cursor_visibility)
Common Key Codes Reference
The Input API uses standard Windows Virtual Key Codes for keyboard input functions.
While common keys are listed below, you can find the complete reference in the
Microsoft Virtual Key Codes Documentation

Common Keys:

Letters: A-Z (65-90)

Numbers: 0-9 (48-57)

Function keys: F1-F12 (112-123)

Backspace (8), Tab (9), Enter (13), Escape (27), Space (32)

Navigation:

Arrows: Left (37), Up (38), Right (39), Down (40)

Page Up (33), Page Down (34), Home (36), End (35)

Modifiers:

Shift (16), Ctrl (17), Alt (18)

Caps Lock (20), Num Lock (144)

Rendering
Functions for drawing text, shapes, images, gradients, and other visual elements.

render.create_font
Signature: render.create_font(font_name, size, weight)

Description: Creates a font with the specified name, size, and weight for use with text rendering functions.

Parameters:

font_name (string): The name of the font (e.g., "Verdana", "Arial", "Tahoma").

size (number): The font size in points.

weight (number): The font weight (thickness). Common values include 400 (normal) and 700 (bold).

Returns:

handle: A font handle to be used with render.draw_text().

Example:

Copy
-- Create a normal Verdana font at 14 points
local normal_font = render.create_font("Verdana", 14, 400)

-- Create a bold Arial font at 24 points
local bold_font = render.create_font("Arial", 24, 700)

-- Use the font to draw text
render.draw_text(normal_font, "Normal Text", 100, 100, 255, 255, 255, 255)
render.draw_text(bold_font, "Bold Text", 100, 130, 255, 255, 255, 255)
render.get_viewport_size
Signature: render.get_viewport_size()

Description: Retrieves the current screen/viewport dimensions.

Parameters: None

Returns:

width (number): The width of the viewport in pixels.

height (number): The height of the viewport in pixels.

Example:

Copy
-- Get the screen dimensions
local screen_width, screen_height = render.get_viewport_size()

-- Log the screen size
engine.log("Screen size: " .. screen_width .. "x" .. screen_height, 255, 255, 255, 255)

-- Center a rectangle on screen
local rect_width, rect_height = 200, 150
local x = (screen_width - rect_width) / 2
local y = (screen_height - rect_height) / 2
render.draw_rectangle(x, y, rect_width, rect_height, 255, 0, 0, 255, 2, false)
render.draw_line
Signature: render.draw_line(x1, y1, x2, y2, r, g, b, a, thickness)

Description: Draws a line between two points with the specified color and thickness.

Parameters:

x1 (number): X-coordinate of the starting point.

y1 (number): Y-coordinate of the starting point.

x2 (number): X-coordinate of the ending point.

y2 (number): Y-coordinate of the ending point.

r (number): Red color component (0-255).

g (number): Green color component (0-255).

b (number): Blue color component (0-255).

a (number): Alpha (transparency) component (0-255).

thickness (number): Line thickness in pixels.

Returns: None

Example:

Copy
-- Draw a white diagonal line with thickness of 2 pixels
render.draw_line(100, 100, 300, 300, 255, 255, 255, 255, 2)

-- Draw a red horizontal line with thickness of 3 pixels
render.draw_line(100, 200, 500, 200, 255, 0, 0, 255, 3)

-- Draw a blue vertical line with thickness of 1 pixel
render.draw_line(400, 100, 400, 400, 0, 0, 255, 255, 1)
render.draw_rectangle
Signature: render.draw_rectangle(x, y, width, height, r, g, b, a, thickness, filled)

Description: Draws a rectangle with the specified position, size, color, and style.

Parameters:

x (number): X-coordinate of the top-left corner.

y (number): Y-coordinate of the top-left corner.

width (number): Width of the rectangle in pixels.

height (number): Height of the rectangle in pixels.

r (number): Red color component (0-255).

g (number): Green color component (0-255).

b (number): Blue color component (0-255).

a (number): Alpha (transparency) component (0-255).

thickness (number): Border thickness in pixels (ignored if filled is true).

filled (boolean): Whether to draw a filled rectangle (true) or just the outline (false).

Returns: None

Example:

Copy
-- Draw a filled red rectangle
render.draw_rectangle(100, 100, 200, 150, 255, 0, 0, 200, 1, true)

-- Draw a green rectangle outline with 3 pixel thickness
render.draw_rectangle(400, 200, 250, 100, 0, 255, 0, 255, 3, false)

-- Draw a semi-transparent blue filled rectangle
render.draw_rectangle(200, 300, 150, 150, 0, 0, 255, 128, 1, true)
render.draw_circle
Signature: render.draw_circle(x, y, radius, r, g, b, a, thickness, filled)

Description: Draws a circle with the specified position, radius, color, and style.

Parameters:

x (number): X-coordinate of the center.

y (number): Y-coordinate of the center.

radius (number): Radius of the circle in pixels.

r (number): Red color component (0-255).

g (number): Green color component (0-255).

b (number): Blue color component (0-255).

a (number): Alpha (transparency) component (0-255).

thickness (number): Border thickness in pixels (ignored if filled is true).

filled (boolean): Whether to draw a filled circle (true) or just the outline (false).

Returns: None

Example:

Copy
-- Draw a filled red circle
render.draw_circle(200, 200, 50, 255, 0, 0, 255, 1, true)

-- Draw a green circle outline with 2 pixel thickness
render.draw_circle(400, 300, 75, 0, 255, 0, 255, 2, false)

-- Draw a semi-transparent blue filled circle
render.draw_circle(600, 400, 100, 0, 0, 255, 128, 1, true)
render.draw_text
Signature: render.draw_text(font, text, x, y, r, g, b, a, outline_thickness, o_r, o_g, o_b, o_a)

Description: Draws text at the specified position with the given font, color, and optional outline.

Parameters:

font (handle): Font handle created with render.create_font().

text (string): The text to draw.

x (number): X-coordinate of the text position.

y (number): Y-coordinate of the text position.

r (number): Red color component (0-255).

g (number): Green color component (0-255).

b (number): Blue color component (0-255).

a (number): Alpha (transparency) component (0-255).

outline_thickness (number, optional): Thickness of the text outline (0 for no outline).

o_r (number, optional): Red color component for the outline (0-255).

o_g (number, optional): Green color component for the outline (0-255).

o_b (number, optional): Blue color component for the outline (0-255).

o_a (number, optional): Alpha component for the outline (0-255).

Returns: None

Example:

Copy
-- Create a font
local font = render.create_font("Arial", 20, 400)

-- Draw white text without outline
render.draw_text(font, "Hello World", 100, 100, 255, 255, 255, 255)

-- Draw red text with black outline
render.draw_text(font, "Outlined Text", 100, 150, 255, 0, 0, 255, 2, 0, 0, 0, 255)

-- Draw green text with white outline
render.draw_text(font, "Green with White Outline", 100, 200, 0, 255, 0, 255, 1, 255, 255, 255, 255)
render.draw_triangle
Signature: render.draw_triangle(x1, y1, x2, y2, x3, y3, r, g, b, a, thickness, filled, rounding)

Description: Draws a triangle connecting three points with the specified color and style.

Parameters:

x1, y1 (number): Coordinates of the first point.

x2, y2 (number): Coordinates of the second point.

x3, y3 (number): Coordinates of the third point.

r (number): Red color component (0-255).

g (number): Green color component (0-255).

b (number): Blue color component (0-255).

a (number): Alpha (transparency) component (0-255).

thickness (number): Border thickness in pixels (ignored if filled is true).

filled (boolean): Whether to draw a filled triangle (true) or just the outline (false).

rounding (number, optional): Corner rounding radius (0 for sharp corners).

Returns: None

Example:

Copy
-- Draw a filled yellow triangle
render.draw_triangle(300, 100, 400, 300, 200, 300, 255, 255, 0, 255, 1, true)

-- Draw a blue triangle outline with 2 pixel thickness
render.draw_triangle(500, 150, 600, 350, 400, 350, 0, 0, 255, 255, 2, false)

-- Draw a filled green triangle with rounded corners
render.draw_triangle(700, 200, 800, 400, 600, 400, 0, 255, 0, 255, 1, true, 5)
render.get_fps
Signature: render.get_fps()

Description: Gets the current frame rate (frames per second) of the overlay.

Parameters: None

Returns:

fps (number): The current frames per second.

Example:

Copy
function display_fps()
    local fps = render.get_fps()
    local color_r, color_g, color_b = 255, 255, 255
    
    -- Change color based on FPS (red if low, yellow if medium, green if high)
    if fps < 30 then
        color_r, color_g, color_b = 255, 0, 0
    elseif fps < 60 then
        color_r, color_g, color_b = 255, 255, 0
    else
        color_r, color_g, color_b = 0, 255, 0
    end
    
    -- Display FPS in the top-right corner
    local font = render.create_font("Consolas", 16, 400)
    local screen_w, screen_h = render.get_viewport_size()
    render.draw_text(font, "FPS: " .. fps, screen_w - 100, 20, color_r, color_g, color_b, 255)
end

engine.register_on_engine_tick(display_fps)
render.create_bitmap_from_url
Signature: render.create_bitmap_from_url(url)

Description: Creates a bitmap image from a URL for rendering on screen.

Parameters:

url (string): The URL of the image to load.

Returns:

bitmap_handle: A handle to the created bitmap for use with rendering functions.

Example:

Copy
-- Load an image from a URL
local bitmap = render.create_bitmap_from_url("https://example.com/image.png")

-- In render function, display the bitmap
function on_render()
    -- Draw the bitmap at position 100,100
    if bitmap then
        -- Implementation depends on how bitmaps are rendered in your API
        -- This is a placeholder:
        render.draw_bitmap(bitmap, 100, 100)
    end
end

engine.register_on_engine_tick(on_render)
render.create_bitmap_from_buffer
Signature: render.create_bitmap_from_buffer(buffer_handle)

Description: Creates a bitmap image from a memory buffer for rendering on screen.

Parameters:

buffer_handle (handle): A memory buffer handle containing image data.

Returns:

bitmap_handle: A handle to the created bitmap for use with rendering functions.

Example:

Copy
-- Assuming we have a buffer with image data (like from a network response)
local response_buffer = net.send_request("https://example.com/image.png")

-- Create bitmap from the buffer
local bitmap = render.create_bitmap_from_buffer(response_buffer)

-- Use the bitmap in rendering
function on_render()
    if bitmap then
        -- Implementation depends on how bitmaps are rendered in your API
        render.draw_bitmap(bitmap, 200, 200)
    end
end
render.create_bitmap_from_file
Signature: render.create_bitmap_from_file(file_name)

Description: Creates a bitmap image from a local file for rendering on screen.

Parameters:

file_name (string): Path to the image file.

Returns:

bitmap_handle: A handle to the created bitmap for use with rendering functions.

Example:

Copy
-- Load an image from a local file
local bitmap = render.create_bitmap_from_file("images/logo.png")

-- Use the bitmap in rendering
function on_render()
    if bitmap then
        -- Implementation depends on how bitmaps are rendered in your API
        render.draw_bitmap(bitmap, 300, 300)
    else
        engine.log("Failed to load bitmap from file", 255, 0, 0, 255)
    end
end
render.clip_start
Signature: render.clip_start(x, y, width, height)

Description: Begins a clipping region. All subsequent rendering will be restricted to this rectangle until render.clip_end() is called.

Parameters:

x (number): X-coordinate of the clipping region's top-left corner.

y (number): Y-coordinate of the clipping region's top-left corner.

width (number): Width of the clipping region in pixels.

height (number): Height of the clipping region in pixels.

Returns: None

Example:

Copy
-- Create a clipping region for a scrollable area
function render_scrollable_content()
    -- Define the visible area
    local visible_area_x = 100
    local visible_area_y = 100
    local visible_area_width = 300
    local visible_area_height = 200
    
    -- Start clipping to the visible area
    render.clip_start(visible_area_x, visible_area_y, visible_area_width, visible_area_height)
    
    -- Draw content that might exceed the visible area
    local font = render.create_font("Arial", 16, 400)
    for i = 1, 30 do
        render.draw_text(font, "Line " .. i, visible_area_x + 10, visible_area_y + (i-1) * 20, 255, 255, 255, 255)
    end
    
    -- End clipping
    render.clip_end()
    
    -- Draw border around the visible area
    render.draw_rectangle(visible_area_x, visible_area_y, visible_area_width, visible_area_height, 255, 255, 255, 255, 1, false)
end
render.clip_end
Signature: render.clip_end()

Description: Ends the active clipping region started by render.clip_start. Restores rendering output to the entire screen or parent context.

Parameters: None

Returns: None

Example:

Copy
-- Create a scrollable text area with clipping
function render_scrollable_text()
    -- Define viewport area (visible region)
    local viewport_x = 100
    local viewport_y = 100
    local viewport_width = 300
    local viewport_height = 200
    
    -- Track scroll position (controlled by mouse wheel)
    local scroll_position = 0
    local scroll_delta = input.get_scroll_delta()
    scroll_position = scroll_position - scroll_delta * 20
    
    -- Content height (larger than viewport)
    local content_height = 500
    
    -- Limit scrolling
    scroll_position = math.clamp(scroll_position, 0, content_height - viewport_height)
    
    -- Begin clipping to viewport area
    render.clip_start(viewport_x, viewport_y, viewport_width, viewport_height)
    
    -- Draw content that extends beyond viewport
    local font = render.create_font("Arial", 16, 400)
    for i = 1, 25 do
        local line_y = viewport_y + (i * 20) - scroll_position
        render.draw_text(font, "Line " .. i .. " of scrollable content", 
                         viewport_x + 10, line_y, 255, 255, 255, 255)
    end
    
    -- End clipping region to restore normal rendering
    render.clip_end()
    
    -- Draw border around viewport (after clip_end so border isn't clipped)
    render.draw_rectangle(viewport_x, viewport_y, viewport_width, viewport_height, 
                          255, 255, 255, 255, 1, false)
    
    -- Draw scroll indicators
    local scroll_percent = scroll_position / (content_height - viewport_height)
    render.draw_text(font, "Scroll: " .. math.floor(scroll_percent * 100) .. "%", 
                     viewport_x, viewport_y - 20, 255, 255, 255, 255)
end

-- Call this function every frame to render the scrollable area
engine.register_on_engine_tick(render_scrollable_text)
render.draw_gradient_rectangle
Signature: render.draw_gradient_rectangle(x, y, width, height, r1, g1, b1, r2, g2, b2, r3, g3, b3, r4, g4, b4)

Description: Draws a rectangle filled with a four-corner gradient. Each corner has its own RGB color value, blended smoothly across the area.

Parameters:

x (number): X-coordinate of the top-left corner.

y (number): Y-coordinate of the top-left corner.

width (number): Width of the rectangle in pixels.

height (number): Height of the rectangle in pixels.

r1, g1, b1 (number): RGB color components for the top-left corner (0-255).

r2, g2, b2 (number): RGB color components for the top-right corner (0-255).

r3, g3, b3 (number): RGB color components for the bottom-left corner (0-255).

r4, g4, b4 (number): RGB color components for the bottom-right corner (0-255).

Returns: None

Example:

Copy
-- Draw a rectangle with a color gradient
-- Top-left: Red, Top-right: Green, Bottom-left: Blue, Bottom-right: Yellow
render.draw_gradient_rectangle(
    100, 100, 400, 300,
    255, 0, 0,    -- Top-left (Red)
    0, 255, 0,    -- Top-right (Green)
    0, 0, 255,    -- Bottom-left (Blue)
    255, 255, 0   -- Bottom-right (Yellow)
)
render.draw_hue_bar
Signature: render.draw_hue_bar(x, y, width, height)

Description: Draws a horizontal or vertical hue gradient bar (HSV spectrum). Commonly used in color pickers for hue selection.

Parameters:

x (number): X-coordinate of the top-left corner.

y (number): Y-coordinate of the top-left corner.

width (number): Width of the bar in pixels.

height (number): Height of the bar in pixels.

Returns: None

Example:

Copy
-- Draw a horizontal hue bar for a color picker
function draw_color_picker()
    -- Draw the hue bar
    local x, y = 100, 100
    local width, height = 300, 20
    render.draw_hue_bar(x, y, width, height)
    
    -- Draw a border around the hue bar
    render.draw_rectangle(x, y, width, height, 255, 255, 255, 255, 1, false)
    
    -- Draw a marker for the currently selected hue (example position)
    local selected_pos = x + width * 0.7  -- 70% from the left
    render.draw_rectangle(selected_pos - 2, y - 3, 4, height + 6, 255, 255, 255, 255, 1, true)
end
GUI
Build custom interfaces with tabs, panels, and interactive elements like checkboxes, sliders, and buttons.

Tab and Panel Creation
gui.get_tab
Signature: gui.get_tab(name)

Description: Retrieves a predefined tab by name.

Parameters:

name (string): The name of the tab to retrieve. Valid values are "aimbot", "visuals", "lua", and "settings".

Returns:

tab (object): A tab object that can be used to create panels and subtabs.

Example:

Copy
-- Get the "lua" tab
local lua_tab = gui.get_tab("lua")

-- Get the "visuals" tab
local visuals_tab = gui.get_tab("visuals")
tab:create_panel
Signature: tab:create_panel(label, small_panel?)

Description: Creates a panel inside a tab.

Parameters:

label (string): The title of the panel.

small_panel (boolean, optional): Whether to create a small panel. Defaults to false.

Returns:

panel (object): A panel object that can be used to add UI elements.

Example:

Copy
-- Get the lua tab and create a panel
local lua_tab = gui.get_tab("lua")
local my_panel = lua_tab:create_panel("My Script Settings")

-- Create a small panel for compact UI
local compact_panel = lua_tab:create_panel("Quick Settings", true)
tab:create_subtab
Signature: tab:create_subtab(label)

Description: Creates a subtab inside a tab.

Parameters:

label (string): The title of the subtab.

Returns:

subtab (object): A subtab object that can be used to create panels.

Example:

Copy
-- Get the visuals tab and create subtabs for different categories
local visuals_tab = gui.get_tab("visuals")
local player_subtab = visuals_tab:create_subtab("Player")
local world_subtab = visuals_tab:create_subtab("World")
local misc_subtab = visuals_tab:create_subtab("Misc")
subtab:create_panel
Signature: subtab:create_panel(label, small_panel?)

Description: Creates a panel inside a subtab.

Parameters:

label (string): The title of the panel.

small_panel (boolean, optional): Whether to create a small panel. Defaults to false.

Returns:

panel (object): A panel object that can be used to add UI elements.

Example:

Copy
-- Get the lua tab, create a subtab, and then create panels in the subtab
local lua_tab = gui.get_tab("lua")
local features_subtab = lua_tab:create_subtab("Features")

-- Create panels in the subtab
local main_panel = features_subtab:create_panel("Main Features")
local extra_panel = features_subtab:create_panel("Extra Features", true)
Panel Widgets
panel:add_checkbox
Signature: panel:add_checkbox(label)

Description: Adds a checkbox to the panel.

Parameters:

label (string): The label for the checkbox.

Returns:

checkbox (object): A checkbox object with methods to get and set its state.

Example:

Copy
-- Create a checkbox
local panel = gui.get_tab("lua"):create_panel("Settings")
local enable_feature = panel:add_checkbox("Enable Feature")

-- Get and set checkbox state
local is_enabled = enable_feature:get()  -- Get current state (true/false)
enable_feature:set(true)  -- Set the checkbox to checked
panel:add_slider_int
Signature: panel:add_slider_int(label, min, max, default)

Description: Adds an integer slider to the panel.

Parameters:

label (string): The label for the slider.

min (number): The minimum value for the slider.

max (number): The maximum value for the slider.

default (number): The default value for the slider.

Returns:

slider_int (object): A slider object with methods to get and set its value.

Example:

Copy
-- Create an integer slider
local panel = gui.get_tab("lua"):create_panel("Settings")
local damage_slider = panel:add_slider_int("Damage", 0, 100, 50)

-- Get and set slider value
local current_damage = damage_slider:get()  -- Get current value (0-100)
damage_slider:set(75)  -- Set the slider to 75
panel:add_slider_float
Signature: panel:add_slider_float(label, min, max, default)

Description: Adds a floating-point slider to the panel.

Parameters:

label (string): The label for the slider.

min (number): The minimum value for the slider.

max (number): The maximum value for the slider.

default (number): The default value for the slider.

Returns:

slider_float (object): A slider object with methods to get and set its value.

Example:

Copy
-- Create a float slider
local panel = gui.get_tab("lua"):create_panel("Settings")
local scale_slider = panel:add_slider_float("Scale", 0.1, 2.0, 1.0)

-- Get and set slider value
local current_scale = scale_slider:get()  -- Get current value (0.1-2.0)
scale_slider:set(1.5)  -- Set the slider to 1.5
panel:add_button
Signature: panel:add_button(label, function)

Description: Adds a button to the panel with a callback function that will be executed when the button is clicked.

Parameters:

label (string): The label for the button.

function (function): The callback function to execute when the button is clicked.

Returns:

button (object): A button object.

Example:

Copy
-- Create a button with a callback
local panel = gui.get_tab("lua"):create_panel("Actions")
local apply_button = panel:add_button("Apply Changes", function()
    engine.log("Button clicked! Applying changes...", 0, 255, 0, 255)
    -- Perform actions when button is clicked
    -- Example: Save settings, apply configuration, etc.
end)
panel:add_text
Signature: panel:add_text(label)

Description: Adds a static text label to the panel.

Parameters:

label (string): The text to display.

Returns:

text (object): A text object with methods to get and set its content.

Example:

Copy
-- Create a text label
local panel = gui.get_tab("lua"):create_panel("Information")
local info_text = panel:add_text("This script enhances gameplay with custom features")

-- Get and set text
local current_text = info_text:get()  -- Get current text
info_text:set("Updated information: Version 2.0")  -- Set new text
panel:add_input_text
Signature: panel:add_input_text(label, default)

Description: Adds a text input box to the panel.

Parameters:

label (string): The label for the input box.

default (string): The default text for the input box.

Returns:

input_text (object): An input text object with methods to get and set its value.

Example:

Copy
-- Create a text input box
local panel = gui.get_tab("lua"):create_panel("Configuration")
local username_input = panel:add_input_text("Username", "Player")

-- Get and set input value
local current_username = username_input:get()  -- Get current text
username_input:set("Pro_Player123")  -- Set new text
panel:add_color_picker
Signature: panel:add_color_picker(label, r, g, b, a)

Description: Adds a color picker to the panel.

Parameters:

label (string): The label for the color picker.

r (number): The default red component (0-255).

g (number): The default green component (0-255).

b (number): The default blue component (0-255).

a (number): The default alpha component (0-255).

Returns:

color_picker (object): A color picker object with methods to get and set its color.

Example:

Copy
-- Create a color picker
local panel = gui.get_tab("visuals"):create_panel("Colors")
local highlight_color = panel:add_color_picker("Highlight Color", 255, 0, 0, 255)  -- Red by default

-- Get current color
local r, g, b, a = highlight_color:get()
engine.log("Current color: R=" .. r .. ", G=" .. g .. ", B=" .. b .. ", A=" .. a, r, g, b, a)

-- Set a new color (green)
highlight_color:set(0, 255, 0, 255)
panel:add_keybind
Signature: panel:add_keybind(label, key, mode)

Description: Adds a keybind to the panel.

Parameters:

label (string): The label for the keybind.

key (number): The default key code.

mode (number): The keybind mode (see key_mode constants).

Returns:

keybind (object): A keybind object with methods to get and set its key and mode.

Example:

Copy
-- Create a keybind with toggle mode
local panel = gui.get_tab("lua"):create_panel("Hotkeys")
local feature_key = panel:add_keybind("Feature Toggle", 70, key_mode.toggle)  -- Key 'F' with toggle mode

-- Get current key and mode
local key = feature_key:get_key()  -- Get current key code
local mode = feature_key:get_mode()  -- Get current mode
local active = feature_key:is_active()  -- Check if keybind is active

-- Set new key and mode
feature_key:set_key(71)  -- Set to key 'G'
feature_key:set_mode(key_mode.onhotkey)  -- Change to on-hotkey mode
panel:add_single_select
Signature: panel:add_single_select(label, list, default_index?)

Description: Adds a single-select dropdown to the panel.

Parameters:

label (string): The label for the dropdown.

list (table): A table of string options.

default_index (number, optional): The default selected index (0).

Returns:

single_select (object): A single-select object with methods to get and set the selected index.

Example:

Copy
-- Create a single-select dropdown
local panel = gui.get_tab("lua"):create_panel("Options")
local weapon_select = panel:add_single_select("Weapon", {"Rifle", "Pistol", "Shotgun", "Sniper"}, 1)

-- Get current selection
local selected_index = weapon_select:get()  -- Get selected index (0-3)
local selected_weapon = {"Rifle", "Pistol", "Shotgun", "Sniper"}[selected_index]
engine.log("Selected weapon: " .. selected_weapon, 255, 255, 255, 255)

-- Set new selection
weapon_select:set(3)  -- Select "Shotgun" (index 3)
panel:add_multi_select
Signature: panel:add_multi_select(label, list)

Description: Adds a multi-select list to the panel.

Parameters:

label (string): The label for the multi-select list.

list (table): A table of string options.

Returns:

multi_select (object): A multi-select object with methods to get and set the state of individual items.

Example:

Copy
-- Create a multi-select list
local panel = gui.get_tab("lua"):create_panel("Features")
local active_features = panel:add_multi_select("Active Features", {"ESP", "Aimbot", "Triggerbot", "Radar"})

-- Set initial selections
active_features:set(1, true)  -- Enable "ESP" (index 1)
active_features:set(3, true)  -- Enable "Triggerbot" (index 3)

-- Check if specific options are selected
if active_features:get(1) then  -- Check if "ESP" is selected
    engine.log("ESP is enabled", 0, 255, 0, 255)
end

if active_features:get(2) then  -- Check if "Aimbot" is selected
    -- Aimbot functionality
end
panel:add_singleselect_list
Signature: panel:add_singleselect_list(label, list)

Description: Adds a single-select list (not dropdown) to the panel.

Parameters:

label (string): The label for the list.

list (table): A table of string options.

Returns:

input_list_single (object): A single-select list object with methods to get and set the selected index.

Example:

Copy
-- Create a single-select list
local panel = gui.get_tab("lua"):create_panel("Configuration")
local mode_list = panel:add_singleselect_list("Game Mode", {"Casual", "Competitive", "Deathmatch", "Training"})

-- Set default selection
mode_list:set(2)  -- Select "Competitive" (index 2)

-- Get current selection
local selected_mode_index = mode_list:get()
local modes = {"Casual", "Competitive", "Deathmatch", "Training"}
engine.log("Selected mode: " .. modes[selected_mode_index], 255, 255, 255, 255)
panel:add_multiselect_list
Signature: panel:add_multiselect_list(label, list)

Description: Adds a multi-select list (not dropdown) to the panel.

Parameters:

label (string): The label for the list.

list (table): A table of string options.

Returns:

input_list_multi (object): A multi-select list object with methods to get and set the state of individual items.

Example:

Copy
-- Create a multi-select list
local panel = gui.get_tab("lua"):create_panel("Configurations")
local target_list = panel:add_multiselect_list("Target Types", {"Players", "Bots", "Friends", "Enemies", "Teammates"})

-- Set initial selections
target_list:set(1, true)  -- Enable "Players" (index 1)
target_list:set(2, true)  -- Enable "Bots" (index 2)
target_list:set(4, true)  -- Enable "Enemies" (index 4)

-- Check if specific options are selected
if target_list:get(1) and target_list:get(4) then
    engine.log("Both Players and Enemies are targeted", 255, 255, 0, 255)
end
Element Control
element:set_active
Signature: element:set_active(bool)

Description: Shows or hides any GUI element.

Parameters:

bool (boolean): true to show the element, false to hide it.

Returns: None

Example:

Copy
-- Create some UI elements
local panel = gui.get_tab("lua"):create_panel("Dynamic UI")
local enable_advanced = panel:add_checkbox("Show Advanced Options")
local advanced_slider = panel:add_slider_int("Advanced Setting", 0, 100, 50)

-- Hide the advanced slider initially
advanced_slider:set_active(false)

-- Create a function to toggle visibility based on checkbox
engine.register_on_engine_tick(function()
    -- Show/hide advanced slider based on checkbox state
    if enable_advanced:get() then
        advanced_slider:set_active(true)
    else
        advanced_slider:set_active(false)
    end
end)
Checkbox Methods
checkbox:get
Signature: checkbox:get()

Description: Gets the current state of a checkbox.

Parameters: None

Returns:

boolean: true if checked, false otherwise.

checkbox:set
Signature: checkbox:set(bool)

Description: Sets the state of a checkbox.

Parameters:

bool (boolean): true to check, false to uncheck.

Returns: None

Slider Methods
slider_int:get / slider_float:get
Signature: slider_int:get() / slider_float:get()

Description: Gets the current value of a slider.

Parameters: None

Returns:

number: The current slider value.

slider_int:set / slider_float:set
Signature: slider_int:set(value) / slider_float:set(value)

Description: Sets the value of a slider.

Parameters:

value (number): The new value for the slider.

Returns: None

Text Methods
text:get
Signature: text:get()

Description: Gets the current text of a text label.

Parameters: None

Returns:

string: The current text.

text:set
Signature: text:set(str)

Description: Sets the text of a text label.

Parameters:

str (string): The new text.

Returns: None

Input Text Methods
input_text:get
Signature: input_text:get()

Description: Gets the current text from an input text field.

Parameters: None

Returns:

string: The current input text.

input_text:set
Signature: input_text:set(str)

Description: Sets the text of an input text field.

Parameters:

str (string): The new text.

Returns: None

Color Picker Methods
color_picker:get
Signature: color_picker:get()

Description: Gets the current RGBA color values from a color picker.

Parameters: None

Returns:

r, g, b, a (numbers): The red, green, blue, and alpha components (0-255).

color_picker:set
Signature: color_picker:set(r, g, b, a)

Description: Sets the RGBA color of a color picker.

Parameters:

r (number): The red component (0-255).

g (number): The green component (0-255).

b (number): The blue component (0-255).

a (number): The alpha component (0-255).

Returns: None

Keybind Methods
keybind:get_key
Signature: keybind:get_key()

Description: Gets the current key code of a keybind.

Parameters: None

Returns:

number: The virtual key code.

keybind:set_key
Signature: keybind:set_key(k)

Description: Sets the key code of a keybind.

Parameters:

k (number): The virtual key code.

Returns: None

keybind:get_mode
Signature: keybind:get_mode()

Description: Gets the current mode of a keybind.

Parameters: None

Returns:

number: The keybind mode (see key_mode constants).

keybind:set_mode
Signature: keybind:set_mode(mode)

Description: Sets the mode of a keybind.

Parameters:

mode (number): The keybind mode (see key_mode constants).

Returns: None

keybind:is_active
Signature: keybind:is_active()

Description: Checks if a keybind is currently active.

Parameters: None

Returns:

boolean: true if the keybind is active, false otherwise.

Select Methods
single_select:get
Signature: single_select:get()

Description: Gets the currently selected index from a single-select dropdown.

Parameters: None

Returns:

number: The selected index (1-based).

single_select:set
Signature: single_select:set(index)

Description: Sets the selected index of a single-select dropdown.

Parameters:

index (number): The index to select (1-based).

Returns: None

multi_select:get
Signature: multi_select:get(index)

Description: Gets the state of a specific item in a multi-select list.

Parameters:

index (number): The index of the item to check (1-based).

Returns:

boolean: true if the item is selected, false otherwise.

multi_select:set
Signature: multi_select:set(index, bool)

Description: Sets the state of a specific item in a multi-select list.

Parameters:

index (number): The index of the item to set (1-based).

bool (boolean): true to select the item, false to deselect it.

Returns: None

GUI State Management
gui.get_state
Signature: gui.get_state()

Description: Serializes the current GUI state to a Base64 string.

Parameters: None

Returns:

string: A Base64-encoded string representing the GUI state.

Example:

Copy
-- Save the current GUI state
local state_string = gui.get_state()
fs.write_to_file("gui_state.cfg", state_string)
engine.log("GUI state saved", 0, 255, 0, 255)
gui.load_state
Signature: gui.load_state(string)

Description: Loads a GUI state from a Base64 string.

Parameters:

string (string): A Base64-encoded state string previously obtained from gui.get_state().

Returns:

boolean: true if the state was loaded successfully, false otherwise.

Example:

Copy
-- Load a saved GUI state
if fs.does_file_exist("gui_state.cfg") then
    local state_string = fs.read_from_file("gui_state.cfg")
    if state_string then
        local success = gui.load_state(state_string)
        if success then
            engine.log("GUI state loaded", 0, 255, 0, 255)
        else
            engine.log("Failed to load GUI state", 255, 0, 0, 255)
        end
    end
end
Keybind Mode Constants
The following constants are used with keybind modes:

key_mode.onhotkey - Active while the key is held down

key_mode.offhotkey - Active while the key is not held down

key_mode.toggle - Toggles between active and inactive states when the key is pressed

key_mode.singlepress - Active for one frame when the key is pressed

key_mode.always_on - Always active, regardless of key state

Example:

Copy
-- Create keybinds with different modes
local panel = gui.get_tab("lua"):create_panel("Keybind Examples")

local toggle_key = panel:add_keybind("Toggle Feature", 84, key_mode.toggle)  -- 'T' key
local hold_key = panel:add_keybind("Hold Feature", 72, key_mode.onhotkey)    -- 'H' key
local single_key = panel:add_keybind("Single Press", 80, key_mode.singlepress)  -- 'P' key
local always_key = panel:add_keybind("Always On", 0, key_mode.always_on)

-- Check keybind states in the game loop
engine.register_on_engine_tick(function()
    if toggle_key:is_active() then
        -- Do something when toggle key is active
    end
    
    if hold_key:is_active() then
        -- Do something while hold key is pressed down
    end
    
    if single_key:is_active() then
        -- Do something on a single press (one frame only)
    end
    
    -- always_key will always return true for is_active()
end)
Memory
Functions for allocating, reading, writing, and freeing memory buffers.

m.alloc
Signature: m.alloc(size)

Description: Allocates a memory block of the specified size and returns a handle to it.

Parameters:

size (number): The size of the memory block to allocate in bytes.

Returns:

handle: A handle to the allocated memory block, or nil if allocation failed.

Example:

Copy
-- Allocate a memory buffer of 1024 bytes
local buffer = m.alloc(1024)

if buffer then
    engine.log("Memory allocation successful", 0, 255, 0, 255)
    
    -- Use the buffer...
    
    -- Free the buffer when done
    m.free(buffer)
else
    engine.log("Memory allocation failed", 255, 0, 0, 255)
end
m.free
Signature: m.free(handle)

Description: Frees a previously allocated memory block.

Parameters:

handle (handle): The handle to the memory block to free.

Returns: None

Example:

Copy
-- Allocate memory
local buffer = m.alloc(2048)

if buffer then
    -- Use the buffer...
    m.write_int32(buffer, 0, 12345)
    
    -- Free the memory when done
    m.free(buffer)
    engine.log("Memory freed successfully", 0, 255, 0, 255)
    
    -- IMPORTANT: Do not use the buffer handle after freeing it!
    -- This would cause undefined behavior or crashes
    -- m.read_int32(buffer, 0)  -- DON'T do this after freeing
end
m.read_double
Signature: m.read_double(handle, offset)

Description: Reads a 64-bit floating-point number (double) from the specified memory buffer at the given offset.

Parameters:

handle (handle): The handle to the memory buffer.

offset (number): The byte offset where the double value starts.

Returns:

number: The double value read from memory.

Example:

Copy
-- Allocate a buffer to store a double value
local buffer = m.alloc(8)  -- Double is 8 bytes

if buffer then
    -- Write a double value to the buffer
    m.write_double(buffer, 0, 3.14159265359)
    
    -- Read the double value back
    local value = m.read_double(buffer, 0)
    engine.log("Read double value: " .. value, 255, 255, 255, 255)
    
    -- Free the buffer when done
    m.free(buffer)
end
m.read_float
Signature: m.read_float(handle, offset)

Description: Reads a 32-bit floating-point number (float) from the specified memory buffer at the given offset.

Parameters:

handle (handle): The handle to the memory buffer.

offset (number): The byte offset where the float value starts.

Returns:

number: The float value read from memory.

Example:

Copy
-- Allocate a buffer to store a float value
local buffer = m.alloc(4)  -- Float is 4 bytes

if buffer then
    -- Write a float value to the buffer
    m.write_float(buffer, 0, 2.7182818)
    
    -- Read the float value back
    local value = m.read_float(buffer, 0)
    engine.log("Read float value: " .. value, 255, 255, 255, 255)
    
    -- Free the buffer when done
    m.free(buffer)
end
m.read_int64
Signature: m.read_int64(handle, offset)

Description: Reads a 64-bit integer from the specified memory buffer at the given offset.

Parameters:

handle (handle): The handle to the memory buffer.

offset (number): The byte offset where the 64-bit integer starts.

Returns:

number: The 64-bit integer value read from memory.

Example:

Copy
-- Allocate a buffer to store a 64-bit integer
local buffer = m.alloc(8)  -- Int64 is 8 bytes

if buffer then
    -- Write a 64-bit integer value to the buffer
    m.write_int64(buffer, 0, 1234567890123456)
    
    -- Read the 64-bit integer value back
    local value = m.read_int64(buffer, 0)
    engine.log("Read int64 value: " .. value, 255, 255, 255, 255)
    
    -- Free the buffer when done
    m.free(buffer)
end
m.read_int32
Signature: m.read_int32(handle, offset)

Description: Reads a 32-bit integer from the specified memory buffer at the given offset.

Parameters:

handle (handle): The handle to the memory buffer.

offset (number): The byte offset where the 32-bit integer starts.

Returns:

number: The 32-bit integer value read from memory.

Example:

Copy
-- Allocate a buffer to store a 32-bit integer
local buffer = m.alloc(4)  -- Int32 is 4 bytes

if buffer then
    -- Write a 32-bit integer value to the buffer
    m.write_int32(buffer, 0, 42)
    
    -- Read the 32-bit integer value back
    local value = m.read_int32(buffer, 0)
    engine.log("Read int32 value: " .. value, 255, 255, 255, 255)
    
    -- Free the buffer when done
    m.free(buffer)
end
m.read_int16
Signature: m.read_int16(handle, offset)

Description: Reads a 16-bit integer from the specified memory buffer at the given offset.

Parameters:

handle (handle): The handle to the memory buffer.

offset (number): The byte offset where the 16-bit integer starts.

Returns:

number: The 16-bit integer value read from memory.

Example:

Copy
-- Allocate a buffer to store multiple values
local buffer = m.alloc(8)  -- Allocate space for multiple values

if buffer then
    -- Write a 16-bit integer value to the buffer at offset 2
    m.write_int16(buffer, 2, 12345)
    
    -- Read the 16-bit integer value back
    local value = m.read_int16(buffer, 2)
    engine.log("Read int16 value: " .. value, 255, 255, 255, 255)
    
    -- Free the buffer when done
    m.free(buffer)
end
m.read_int8
Signature: m.read_int8(handle, offset)

Description: Reads an 8-bit integer from the specified memory buffer at the given offset.

Parameters:

handle (handle): The handle to the memory buffer.

offset (number): The byte offset where the 8-bit integer starts.

Returns:

number: The 8-bit integer value read from memory.

Example:

Copy
-- Allocate a buffer to store a byte array
local buffer = m.alloc(4)  -- Allocate 4 bytes

if buffer then
    -- Write byte values to different offsets in the buffer
    m.write_int8(buffer, 0, 65)  -- ASCII 'A'
    m.write_int8(buffer, 1, 66)  -- ASCII 'B'
    m.write_int8(buffer, 2, 67)  -- ASCII 'C'
    m.write_int8(buffer, 3, 0)   -- Null terminator
    
    -- Read the byte values back
    local a = m.read_int8(buffer, 0)
    local b = m.read_int8(buffer, 1)
    local c = m.read_int8(buffer, 2)
    
    engine.log("Read bytes: " .. a .. ", " .. b .. ", " .. c, 255, 255, 255, 255)
    engine.log("As ASCII: " .. string.char(a, b, c), 255, 255, 255, 255)
    
    -- Or read as a string
    local str = m.read_string(buffer, 0)
    engine.log("Read string: " .. str, 255, 255, 255, 255)
    
    -- Free the buffer when done
    m.free(buffer)
end
m.read_string
Signature: m.read_string(handle, offset)

Description: Reads a null-terminated string from the specified memory buffer at the given offset.

Parameters:

handle (handle): The handle to the memory buffer.

offset (number): The byte offset where the string starts.

Returns:

string: The string read from memory.

Example:

Copy
-- Allocate a buffer for storing a string
local buffer = m.alloc(32)  -- Allocate 32 bytes for a string

if buffer then
    -- Write a string to the buffer (including null terminator)
    m.write_string(buffer, 0, "Hello, World!")
    
    -- Read the string back
    local str = m.read_string(buffer, 0)
    engine.log("Read string: " .. str, 255, 255, 255, 255)
    
    -- Free the buffer when done
    m.free(buffer)
end
m.read_wide_string
Signature: m.read_wide_string(handle, offset)

Description: Reads a null-terminated wide (UTF-16) string from the specified memory buffer at the given offset.

Parameters:

handle (handle): The handle to the memory buffer.

offset (number): The byte offset where the wide string starts.

Returns:

string: The wide string read from memory, converted to a Lua UTF-8 string.

Example:

Copy
-- Allocate a buffer for storing a wide string
local buffer = m.alloc(32)  -- Allocate 32 bytes for a string (16 UTF-16 characters)

if buffer then
    -- Write a wide string to the buffer
    m.write_wide_string(buffer, 0, "Hello, !")
    
    -- Read the wide string back
    local str = m.read_wide_string(buffer, 0)
    engine.log("Read wide string: " .. str, 255, 255, 255, 255)
    
    -- Free the buffer when done
    m.free(buffer)
end
m.write_double
Signature: m.write_double(handle, offset, value)

Description: Writes a 64-bit floating-point number (double) to the specified memory buffer at the given offset.

Parameters:

handle (handle): The handle to the memory buffer.

offset (number): The byte offset where the double value should be written.

value (number): The double value to write.

Returns: None

Example:

Copy
-- Allocate a buffer for multiple doubles
local buffer = m.alloc(16)  -- Allocate 16 bytes (2 doubles)

if buffer then
    -- Write two double values to the buffer
    m.write_double(buffer, 0, 3.14159265359)  -- Pi
    m.write_double(buffer, 8, 2.71828182846)  -- e
    
    -- Read the values back to verify
    local pi = m.read_double(buffer, 0)
    local e = m.read_double(buffer, 8)
    
    engine.log("Pi: " .. pi, 255, 255, 255, 255)
    engine.log("e: " .. e, 255, 255, 255, 255)
    
    -- Free the buffer when done
    m.free(buffer)
end
m.write_float
Signature: m.write_float(handle, offset, value)

Description: Writes a 32-bit floating-point number (float) to the specified memory buffer at the given offset.

Parameters:

handle (handle): The handle to the memory buffer.

offset (number): The byte offset where the float value should be written.

value (number): The float value to write.

Returns: None

Example:

Copy
-- Allocate a buffer for an array of floats
local float_count = 5
local buffer = m.alloc(float_count * 4)  -- Each float is 4 bytes

if buffer then
    -- Write a sequence of float values
    for i = 0, float_count-1 do
        m.write_float(buffer, i * 4, i * 1.5)
    end
    
    -- Read back all values
    for i = 0, float_count-1 do
        local value = m.read_float(buffer, i * 4)
        engine.log("Float at index " .. i .. ": " .. value, 255, 255, 255, 255)
    end
    
    -- Free the buffer when done
    m.free(buffer)
end
m.write_int64
Signature: m.write_int64(handle, offset, value)

Description: Writes a 64-bit integer to the specified memory buffer at the given offset.

Parameters:

handle (handle): The handle to the memory buffer.

offset (number): The byte offset where the 64-bit integer should be written.

value (number): The 64-bit integer value to write.

Returns: None

Example:

Copy
-- Allocate a buffer for a 64-bit integer
local buffer = m.alloc(8)  -- Int64 is 8 bytes

if buffer then
    -- Write a 64-bit integer value
    local big_number = 9223372036854775807  -- Max int64 value
    m.write_int64(buffer, 0, big_number)
    
    -- Read the value back
    local value = m.read_int64(buffer, 0)
    engine.log("Int64 value: " .. value, 255, 255, 255, 255)
    
    -- Free the buffer when done
    m.free(buffer)
end
m.write_int32
Signature: m.write_int32(handle, offset, value)

Description: Writes a 32-bit integer to the specified memory buffer at the given offset.

Parameters:

handle (handle): The handle to the memory buffer.

offset (number): The byte offset where the 32-bit integer should be written.

value (number): The 32-bit integer value to write.

Returns: None

Example:

Copy
-- Allocate a buffer for multiple integers
local buffer = m.alloc(12)  -- Space for 3 int32 values

if buffer then
    -- Write integer values at different offsets
    m.write_int32(buffer, 0, 123)
    m.write_int32(buffer, 4, 456)
    m.write_int32(buffer, 8, 789)
    
    -- Read all values back
    local val1 = m.read_int32(buffer, 0)
    local val2 = m.read_int32(buffer, 4)
    local val3 = m.read_int32(buffer, 8)
    
    engine.log("Values: " .. val1 .. ", " .. val2 .. ", " .. val3, 255, 255, 255, 255)
    
    -- Free the buffer when done
    m.free(buffer)
end
m.write_int16
Signature: m.write_int16(handle, offset, value)

Description: Writes a 16-bit integer to the specified memory buffer at the given offset.

Parameters:

handle (handle): The handle to the memory buffer.

offset (number): The byte offset where the 16-bit integer should be written.

value (number): The 16-bit integer value to write.

Returns: None

Example:

Copy
-- Allocate a buffer for a struct with mixed data types
local buffer = m.alloc(8)

if buffer then
    -- Write 16-bit integers at different offsets
    m.write_int16(buffer, 0, 12345)  -- First int16
    m.write_int16(buffer, 2, -1)     -- Second int16 (negative value)
    m.write_int16(buffer, 4, 0)      -- Third int16
    m.write_int16(buffer, 6, 32767)  -- Fourth int16 (max positive value)
    
    -- Read the values back
    local val1 = m.read_int16(buffer, 0)
    local val2 = m.read_int16(buffer, 2)
    local val3 = m.read_int16(buffer, 4)
    local val4 = m.read_int16(buffer, 6)
    
    engine.log("Int16 values: " .. val1 .. ", " .. val2 .. ", " .. 
               val3 .. ", " .. val4, 255, 255, 255, 255)
    
    -- Free the buffer when done
    m.free(buffer)
end
m.write_int8
Signature: m.write_int8(handle, offset, value)

Description: Writes an 8-bit integer to the specified memory buffer at the given offset.

Parameters:

handle (handle): The handle to the memory buffer.

offset (number): The byte offset where the 8-bit integer should be written.

value (number): The 8-bit integer value to write.

Returns: None

Example:

Copy
-- Allocate a buffer for a byte array
local buffer = m.alloc(4)

if buffer then
    -- Write a sequence of bytes (RGBA color)
    m.write_int8(buffer, 0, 255)  -- Red
    m.write_int8(buffer, 1, 128)  -- Green
    m.write_int8(buffer, 2, 64)   -- Blue
    m.write_int8(buffer, 3, 255)  -- Alpha
    
    -- Read the color components back
    local r = m.read_int8(buffer, 0)
    local g = m.read_int8(buffer, 1)
    local b = m.read_int8(buffer, 2)
    local a = m.read_int8(buffer, 3)
    
    engine.log("RGBA Color: " .. r .. ", " .. g .. ", " .. b .. ", " .. a,
               r, g, b, a)
    
    -- Free the buffer when done
    m.free(buffer)
end
m.write_string
Signature: m.write_string(handle, offset, str)

Description: Writes a null-terminated string to the specified memory buffer at the given offset.

Parameters:

handle (handle): The handle to the memory buffer.

offset (number): The byte offset where the string should be written.

str (string): The string to write.

Returns: None

Example:

Copy
-- Allocate a buffer for a string
local buffer = m.alloc(64)  -- Allocate more than enough space

if buffer then
    -- Write a string to the buffer
    local message = "Hello from Lua!"
    m.write_string(buffer, 0, message)
    
    -- Read the string back
    local read_message = m.read_string(buffer, 0)
    engine.log("Written string: " .. read_message, 255, 255, 255, 255)
    
    -- Write another string at an offset
    m.write_string(buffer, 20, "Second string")
    
    -- Read the second string back
    local second_message = m.read_string(buffer, 20)
    engine.log("Second string: " .. second_message, 255, 255, 255, 255)
    
    -- Free the buffer when done
    m.free(buffer)
end
m.write_wide_string
Signature: m.write_wide_string(handle, offset, str)

Description: Writes a null-terminated wide (UTF-16) string to the specified memory buffer at the given offset.

Parameters:

handle (handle): The handle to the memory buffer.

offset (number): The byte offset where the wide string should be written.

str (string): The string to write (will be converted to UTF-16).

Returns: None

Example:

Copy
-- Allocate a buffer for a wide string
local buffer = m.alloc(64)  -- Allocate space for wide string

if buffer then
    -- Write a Unicode string to the buffer as a wide string
    local message = "Unicode Text: , , "
    m.write_wide_string(buffer, 0, message)
    
    -- Read the wide string back
    local read_message = m.read_wide_string(buffer, 0)
    engine.log("Unicode string: " .. read_message, 255, 255, 255, 255)
    
    -- Free the buffer when done
    m.free(buffer)
end
m.get_size
Signature: m.get_size(handle)

Description: Returns the total size in bytes of the allocated memory buffer.

Parameters:

handle (handle): The handle to the memory buffer.

Returns:

number: The size of the buffer in bytes.

Example:

Copy
-- Allocate a buffer
local buffer_size = 1024
local buffer = m.alloc(buffer_size)

if buffer then
    -- Get the actual allocated size
    local size = m.get_size(buffer)
    
    engine.log("Requested " .. buffer_size .. " bytes, allocated " .. size .. " bytes", 
               255, 255, 255, 255)
    
    -- Use the buffer...
    
    -- Free the buffer when done
    m.free(buffer)
end
Process
Functions for interacting with process memory, modules, and state.

Process Info & State
proc.is_attached
Signature: proc.is_attached()

Description: Returns true if a process is currently attached.

Parameters: None

Returns:

boolean: true if a process is attached, false otherwise.

Example:

Copy
if proc.is_attached() then
    engine.log("Process attached successfully", 0, 255, 0, 255)
    -- Proceed with process operations
else
    engine.log("No process attached", 255, 0, 0, 255)
end
proc.did_exit
Signature: proc.did_exit()

Description: Returns true if the attached process has exited.

Parameters: None

Returns:

boolean: true if the attached process has exited, false otherwise.

Example:

Copy
function check_process_state()
    if proc.is_attached() then
        if proc.did_exit() then
            engine.log("Attached process has exited!", 255, 0, 0, 255)
            -- Handle cleanup
        else
            engine.log("Process is still running", 0, 255, 0, 255)
        end
    end
end

engine.register_on_engine_tick(check_process_state)
proc.pid
Signature: proc.pid()

Description: Returns the process ID of the attached process.

Parameters: None

Returns:

number: The process ID (PID) of the attached process.

Example:

Copy
if proc.is_attached() then
    local pid = proc.pid()
    engine.log("Attached to process with PID: " .. pid, 255, 255, 255, 255)
end
proc.peb
Signature: proc.peb()

Description: Returns the address of the Process Environment Block (PEB) of the attached process.

Parameters: None

Returns:

number: The address of the PEB of the attached process.

Example:

Copy
if proc.is_attached() then
    local peb_address = proc.peb()
    engine.log("PEB address: 0x" .. string.format("%X", peb_address), 255, 255, 255, 255)
end
proc.base_address
Signature: proc.base_address()

Description: Returns the base address of the attached process.

Parameters: None

Returns:

number: The base address of the attached process.

Example:

Copy
if proc.is_attached() then
    local base = proc.base_address()
    engine.log("Process base address: 0x" .. string.format("%X", base), 255, 255, 255, 255)
    
    -- Read a value at an offset from the base address
    local value = proc.read_int32(base + 0x1000)
    engine.log("Value at base+0x1000: " .. value, 255, 255, 255, 255)
end
proc.get_base_module
Signature: proc.get_base_module()

Description: Returns the base address and size of the main module of the attached process.

Parameters: None

Returns:

address (number): The base address of the main module.

size (number): The size of the main module in bytes.

Example:

Copy
if proc.is_attached() then
    local base_address, module_size = proc.get_base_module()
    engine.log("Main module base: 0x" .. string.format("%X", base_address), 255, 255, 255, 255)
    engine.log("Main module size: " .. module_size .. " bytes", 255, 255, 255, 255)
end
proc.find_module
Signature: proc.find_module(module_name)

Description: Finds a module by name and returns its base address and size.

Parameters:

module_name (string): The name of the module to find (e.g., "kernel32.dll").

Returns:

address (number): The base address of the found module, or nil if not found.

size (number): The size of the found module in bytes.

Example:

Copy
if proc.is_attached() then
    local dll_name = "user32.dll"
    local module_base, module_size = proc.find_module(dll_name)
    
    if module_base then
        engine.log("Found module '" .. dll_name .. "' at 0x" .. 
                  string.format("%X", module_base) .. " with size " .. 
                  module_size .. " bytes", 0, 255, 0, 255)
    else
        engine.log("Module '" .. dll_name .. "' not found", 255, 0, 0, 255)
    end
end
proc.find_signature
Signature: proc.find_signature(base_address, size, signature)

Description: Searches for a memory pattern (signature) within a specified memory range.

Parameters:

base_address (number): The starting address to begin the search.

size (number): The number of bytes to search.

signature (string): The pattern to search for (e.g., "48 8B 05 ?? ?? ?? ??").

Returns:

address (number): The address where the pattern was found, or nil if not found.

Example:

Copy
if proc.is_attached() then
    local base_address, module_size = proc.get_base_module()
    
    -- Example signature with wildcards (??)
    local signature = "48 8B 05 ?? ?? ?? ?? 48 85 C0 74 10"
    
    local result = proc.find_signature(base_address, module_size, signature)
    if result then
        engine.log("Signature found at: 0x" .. string.format("%X", result), 0, 255, 0, 255)
    else
        engine.log("Signature not found in memory range", 255, 0, 0, 255)
    end
end
Memory Read Operations
proc.read_double
Signature: proc.read_double(address)

Description: Reads a 64-bit floating-point number (double) from the specified memory address.

Parameters:

address (number): The memory address to read from.

Returns:

number: The double value read from memory.

Example:

Copy
if proc.is_attached() then
    local address = 0x12345678  -- Replace with an actual address
    local value = proc.read_double(address)
    engine.log("Double value: " .. value, 255, 255, 255, 255)
end
proc.read_float
Signature: proc.read_float(address)

Description: Reads a 32-bit floating-point number (float) from the specified memory address.

Parameters:

address (number): The memory address to read from.

Returns:

number: The float value read from memory.

Example:

Copy
if proc.is_attached() then
    local base = proc.base_address()
    local offset = 0x1234  -- Replace with an actual offset
    local value = proc.read_float(base + offset)
    engine.log("Float value: " .. value, 255, 255, 255, 255)
end
proc.read_int64
Signature: proc.read_int64(address)

Description: Reads a 64-bit integer from the specified memory address.

Parameters:

address (number): The memory address to read from.

Returns:

number: The 64-bit integer value read from memory.

Example:

Copy
if proc.is_attached() then
    local address = 0x12345678  -- Replace with an actual address
    local value = proc.read_int64(address)
    engine.log("Int64 value: " .. value, 255, 255, 255, 255)
end
proc.read_int32
Signature: proc.read_int32(address)

Description: Reads a 32-bit integer from the specified memory address.

Parameters:

address (number): The memory address to read from.

Returns:

number: The 32-bit integer value read from memory.

Example:

Copy
if proc.is_attached() then
    local base = proc.base_address()
    local offset = 0x1000  -- Replace with an actual offset
    local value = proc.read_int32(base + offset)
    engine.log("Int32 value: " .. value, 255, 255, 255, 255)
end
proc.read_int16
Signature: proc.read_int16(address)

Description: Reads a 16-bit integer from the specified memory address.

Parameters:

address (number): The memory address to read from.

Returns:

number: The 16-bit integer value read from memory.

Example:

Copy
if proc.is_attached() then
    local address = 0x12345678  -- Replace with an actual address
    local value = proc.read_int16(address)
    engine.log("Int16 value: " .. value, 255, 255, 255, 255)
end
proc.read_int8
Signature: proc.read_int8(address)

Description: Reads an 8-bit integer from the specified memory address.

Parameters:

address (number): The memory address to read from.

Returns:

number: The 8-bit integer value read from memory.

Example:

Copy
if proc.is_attached() then
    local base = proc.base_address()
    local offset = 0x2000  -- Replace with an actual offset
    local value = proc.read_int8(base + offset)
    engine.log("Int8 value: " .. value, 255, 255, 255, 255)
end
proc.read_string
Signature: proc.read_string(address, size)

Description: Reads a string from the specified memory address with the given maximum size.

Parameters:

address (number): The memory address to read from.

size (number): The maximum number of bytes to read.

Returns:

string: The string read from memory.

Example:

Copy
if proc.is_attached() then
    local string_address = 0x12345678  -- Replace with an actual address
    local max_size = 64
    local text = proc.read_string(string_address, max_size)
    engine.log("String value: " .. text, 255, 255, 255, 255)
end
proc.read_wide_string
Signature: proc.read_wide_string(address, size)

Description: Reads a wide (UTF-16) string from the specified memory address with the given maximum size.

Parameters:

address (number): The memory address to read from.

size (number): The maximum number of wide characters to read.

Returns:

string: The wide string read from memory, converted to a Lua UTF-8 string.

Example:

Copy
if proc.is_attached() then
    local wide_string_address = 0x12345678  -- Replace with an actual address
    local max_size = 32
    local text = proc.read_wide_string(wide_string_address, max_size)
    engine.log("Wide string value: " .. text, 255, 255, 255, 255)
end
proc.read_to_memory_buffer
Signature: proc.read_to_memory_buffer(address, buffer, size)

Description: Reads memory from the attached process into a local memory buffer.

Parameters:

address (number): The memory address to read from.

buffer (handle): A memory buffer handle obtained from m.alloc().

size (number): The number of bytes to read.

Returns:

boolean: true if the read operation was successful, false otherwise.

Example:

Copy
if proc.is_attached() then
    -- Allocate a buffer to hold the memory data
    local buffer_size = 1024
    local buffer = m.alloc(buffer_size)
    
    if buffer then
        local address = proc.base_address() + 0x1000  -- Replace with an actual address
        
        -- Read memory into the buffer
        local success = proc.read_to_memory_buffer(address, buffer, buffer_size)
        
        if success then
            engine.log("Successfully read " .. buffer_size .. " bytes to buffer", 0, 255, 0, 255)
            
            -- Process the buffer data (for example, read the first int32)
            local value = m.read_int32(buffer, 0)
            engine.log("First int32 in buffer: " .. value, 255, 255, 255, 255)
        else
            engine.log("Failed to read memory to buffer", 255, 0, 0, 255)
        end
        
        -- Free the buffer when done
        m.free(buffer)
    end
end
Memory Write Operations
proc.write_double
Signature: proc.write_double(address, value)

Description: Writes a 64-bit floating-point number (double) to the specified memory address.

Parameters:

address (number): The memory address to write to.

value (number): The double value to write.

Returns:

boolean: true if the write operation was successful, false otherwise.

Example:

Copy
if proc.is_attached() then
    local address = 0x12345678  -- Replace with an actual address
    local value = 3.14159265359
    
    local success = proc.write_double(address, value)
    if success then
        engine.log("Successfully wrote double value " .. value, 0, 255, 0, 255)
    else
        engine.log("Failed to write double value", 255, 0, 0, 255)
    end
end
proc.write_float
Signature: proc.write_float(address, value)

Description: Writes a 32-bit floating-point number (float) to the specified memory address.

Parameters:

address (number): The memory address to write to.

value (number): The float value to write.

Returns:

boolean: true if the write operation was successful, false otherwise.

Example:

Copy
if proc.is_attached() then
    local base = proc.base_address()
    local offset = 0x1234  -- Replace with an actual offset
    local value = 2.71828
    
    local success = proc.write_float(base + offset, value)
    if success then
        engine.log("Successfully wrote float value " .. value, 0, 255, 0, 255)
    else
        engine.log("Failed to write float value", 255, 0, 0, 255)
    end
end
proc.write_int64
Signature: proc.write_int64(address, value)

Description: Writes a 64-bit integer to the specified memory address.

Parameters:

address (number): The memory address to write to.

value (number): The 64-bit integer value to write.

Returns:

boolean: true if the write operation was successful, false otherwise.

Example:

Copy
if proc.is_attached() then
    local address = 0x12345678  -- Replace with an actual address
    local value = 1234567890123456
    
    local success = proc.write_int64(address, value)
    if success then
        engine.log("Successfully wrote int64 value " .. value, 0, 255, 0, 255)
    else
        engine.log("Failed to write int64 value", 255, 0, 0, 255)
    end
end
proc.write_int32
Signature: proc.write_int32(address, value)

Description: Writes a 32-bit integer to the specified memory address.

Parameters:

address (number): The memory address to write to.

value (number): The 32-bit integer value to write.

Returns:

boolean: true if the write operation was successful, false otherwise.

Example:

Copy
if proc.is_attached() then
    local base = proc.base_address()
    local offset = 0x1000  -- Replace with an actual offset
    local value = 42
    
    -- Read the original value first
    local original = proc.read_int32(base + offset)
    engine.log("Original value: " .. original, 255, 255, 255, 255)
    
    -- Write the new value
    local success = proc.write_int32(base + offset, value)
    if success then
        -- Verify the write by reading back
        local new_value = proc.read_int32(base + offset)
        engine.log("New value: " .. new_value, 0, 255, 0, 255)
    else
        engine.log("Failed to write int32 value", 255, 0, 0, 255)
    end
end
proc.write_int16
Signature: proc.write_int16(address, value)

Description: Writes a 16-bit integer to the specified memory address.

Parameters:

address (number): The memory address to write to.

value (number): The 16-bit integer value to write.

Returns:

boolean: true if the write operation was successful, false otherwise.

Example:

Copy
if proc.is_attached() then
    local address = 0x12345678  -- Replace with an actual address
    local value = 12345  -- 16-bit value (max 65535)
    
    local success = proc.write_int16(address, value)
    if success then
        engine.log("Successfully wrote int16 value " .. value, 0, 255, 0, 255)
    else
        engine.log("Failed to write int16 value", 255, 0, 0, 255)
    end
end
proc.write_int8
Signature: proc.write_int8(address, value)

Description: Writes an 8-bit integer to the specified memory address.

Parameters:

address (number): The memory address to write to.

value (number): The 8-bit integer value to write.

Returns:

boolean: true if the write operation was successful, false otherwise.

Example:

Copy
if proc.is_attached() then
    local base = proc.base_address()
    local offset = 0x2000  -- Replace with an actual offset
    local value = 127  -- 8-bit value (max 255)
    
    local success = proc.write_int8(base + offset, value)
    if success then
        engine.log("Successfully wrote int8 value " .. value, 0, 255, 0, 255)
    else
        engine.log("Failed to write int8 value", 255, 0, 0, 255)
    end
end
proc.write_string
Signature: proc.write_string(address, text)

Description: Writes a string to the specified memory address.

Parameters:

address (number): The memory address to write to.

text (string): The string to write (null terminated).

Returns:

boolean: true if the write operation was successful, false otherwise.

Example:

Copy
if proc.is_attached() then
    local string_address = 0x12345678  -- Replace with an actual address
    local text = "Hello, Process Memory!"
    
    local success = proc.write_string(string_address, text)
    if success then
        engine.log("Successfully wrote string to memory", 0, 255, 0, 255)
        
        -- Verify by reading back
        local read_text = proc.read_string(string_address, #text + 1)
        engine.log("Read back: " .. read_text, 255, 255, 255, 255)
    else
        engine.log("Failed to write string to memory", 255, 0, 0, 255)
    end
end
proc.write_wide_string
Signature: proc.write_wide_string(address, text)

Description: Writes a wide (UTF-16) string to the specified memory address.

Parameters:

address (number): The memory address to write to.

text (string): The string to write as a wide string (will be converted to UTF-16).

Returns:

boolean: true if the write operation was successful, false otherwise.

Example:

Copy
if proc.is_attached() then
    local wide_string_address = 0x12345678  -- Replace with an actual address
    local text = "Unicode Text: , , "
    
    local success = proc.write_wide_string(wide_string_address, text)
    if success then
        engine.log("Successfully wrote wide string to memory", 0, 255, 0, 255)
        
        -- Verify by reading back (chars * 2 for UTF-16)
        local read_text = proc.read_wide_string(wide_string_address, #text)
        engine.log("Read back: " .. read_text, 255, 255, 255, 255)
    else
        engine.log("Failed to write wide string to memory", 255, 0, 0, 255)
    end
end
proc.write_from_memory_buffer
Signature: proc.write_from_memory_buffer(address, buffer, size)

Description: Writes memory from a local buffer to the attached process's memory.

Parameters:

address (number): The memory address to write to.

buffer (handle): A memory buffer handle obtained from m.alloc().

size (number): The number of bytes to write.

Returns:

boolean: true if the write operation was successful, false otherwise.

Example:

Copy
if proc.is_attached() then
    -- Allocate and prepare a buffer
    local buffer_size = 16
    local buffer = m.alloc(buffer_size)
    
    if buffer then
        -- Fill the buffer with some values
        m.write_int32(buffer, 0, 0x12345678)
        m.write_int32(buffer, 4, 0x9ABCDEF0)
        m.write_int32(buffer, 8, 0x11223344)
        m.write_int32(buffer, 12, 0x55667788)
        
        -- Write the buffer to process memory
        local target_address = proc.base_address() + 0x3000  -- Replace with an actual address
        local success = proc.write_from_memory_buffer(target_address, buffer, buffer_size)
        
        if success then
            engine.log("Successfully wrote " .. buffer_size .. " bytes from buffer to memory", 0, 255, 0, 255)
        else
            engine.log("Failed to write from buffer to memory", 255, 0, 0, 255)
        end
        
        -- Free the buffer when done
        m.free(buffer)
    end
end
Networking
Functions for HTTP requests, sockets, and Base64 encoding.

net.send_request
Signature: net.send_request(url, headers, post_fields)

Description: Sends an HTTP request with optional headers and POST data. The response will be delivered asynchronously to a callback registered with engine.register_on_network_callback().

Parameters:

url (string): The URL to send the request to.

headers (string, optional): HTTP headers to include with the request.

post_fields (string, optional): Data to send in a POST request. If not provided, a GET request will be sent.

Returns: None

Example:

Copy
-- Register a callback to handle responses
function handle_network_response(response_data, url)
    -- Read the response data from the buffer
    local response_text = memory.read_string(response_data, 0)
    
    engine.log("Received response from: " .. url, 0, 255, 0, 255)
    engine.log("Response length: " .. string.len(response_text) .. " characters", 255, 255, 255, 255)
    
    -- You can also save the response to a file
    fs.write_to_file_from_buffer("response.txt", response_data)
    
    -- If response is JSON, try to parse it
    if string.match(url, "%.json") then
        local success, parsed = pcall(json.decode, response_text)
        if success and parsed then
            engine.log("Successfully parsed JSON response", 0, 255, 0, 255)
            process_json_data(parsed, url)
        else
            engine.log("Failed to parse JSON response", 255, 0, 0, 255)
        end
    end
end

-- Process JSON data based on the URL
function process_json_data(data, url)
    -- Example: Process bank holidays JSON
    if string.match(url, "bank%-holidays%.json") then
        -- Current date for comparison (YYYY-MM-DD format)
        local today = os.date("%Y-%m-%d")
        
        -- Access the 'england-and-wales' holidays section
        local region = data["england-and-wales"]
        local events = region and region["events"]
        
        if not events then
            engine.log("No events found for 'england-and-wales'", 255, 0, 0, 255)
            return
        end
        
        -- Find the next upcoming event
        local next_holiday = nil
        for _, event in ipairs(events) do
            if event.date > today then
                next_holiday = event
                break
            end
        end
        
        -- Output the result
        if next_holiday then
            engine.log("Next Bank Holiday: " .. next_holiday.title, 0, 255, 200, 255)
            engine.log("Date: " .. next_holiday.date, 0, 200, 255, 255)
        else
            engine.log("No upcoming holidays found.", 255, 255, 0, 255)
        end
    end
end

-- Register the network callback
engine.register_callback("network", handle_network_response)

-- Send a GET request
function send_get_request()
    local url = "https://example.com/api/data"
    local headers = "User-Agent: MyLuaScript/1.0"
    
    networking.http_get(url, headers)
    engine.log("GET request sent to: " .. url, 255, 255, 255, 255)
end

-- Send a POST request
function send_post_request()
    local url = "https://example.com/api/submit"
    local headers = "User-Agent: MyLuaScript/1.0\r\nContent-Type: application/x-www-form-urlencoded"
    local post_data = "param1=value1&param2=value2"
    
    networking.http_post(url, headers, post_data)
    engine.log("POST request sent to: " .. url, 255, 255, 255, 255)
end

-- Get UK bank holidays
function get_bank_holidays()
    local url = "https://www.gov.uk/bank-holidays.json"
    networking.http_get(url)
    engine.log("Requesting UK bank holidays...", 255, 255, 0, 255)
end

-- Execute the request functions
-- Uncomment the ones you want to use
-- send_get_request()
-- send_post_request()
get_bank_holidays()
net.resolve
Signature: net.resolve(hostname)

Description: Looks up the first IPv4 or IPv6 address for a hostname.

Parameters:

hostname (string): The hostname to resolve (e.g., "google.com").

Returns:

string: The resolved IP address, or nil if resolution failed.

Example:

Copy
function resolve_hostname(hostname)
    local ip = net.resolve(hostname)
    
    if ip then
        engine.log("Resolved " .. hostname .. " to " .. ip, 0, 255, 0, 255)
        return ip
    else
        engine.log("Failed to resolve " .. hostname, 255, 0, 0, 255)
        return nil
    end
end

-- Usage example
local google_ip = resolve_hostname("google.com")
local nonexistent_ip = resolve_hostname("this-does-not-exist.example")
net.create_socket
Signature: net.create_socket(ip, port)

Description: Opens a TCP connection to the specified IP address and port, returning a socket object.

Parameters:

ip (string): The IP address to connect to.

port (number): The port number to connect to.

Returns:

socket (table): A socket object with methods for sending and receiving data, or nil if connection failed.

error (string): An error message if the connection failed.

Example:

Copy
function connect_to_server(hostname, port)
    -- First resolve the hostname to an IP address
    local ip = net.resolve(hostname)
    if not ip then
        engine.log("Failed to resolve hostname: " .. hostname, 255, 0, 0, 255)
        return nil
    end
    
    -- Connect to the server
    local socket, error = net.create_socket(ip, port)
    if not socket then
        engine.log("Failed to connect: " .. error, 255, 0, 0, 255)
        return nil
    end
    
    engine.log("Connected to " .. hostname .. " (" .. ip .. ":" .. port .. ")", 0, 255, 0, 255)
    return socket
end

-- Usage example: Connect to a web server
local socket = connect_to_server("example.com", 80)
socket:send
Signature: socket:send(data)

Description: Sends data on a socket created with net.create_socket().

Parameters:

data (string): The raw string data to send on the socket.

Returns:

bytes_sent (number): The number of bytes sent, or nil if the send operation failed.

error (string): An error message if the send operation failed.

Example:

Copy
function send_http_request(hostname, path)
    local socket = connect_to_server(hostname, 80)
    if not socket then
        return false
    end
    
    -- Build a simple HTTP request
    local request = table.concat({
        "GET " .. path .. " HTTP/1.1",
        "Host: " .. hostname,
        "Connection: close",
        "User-Agent: Lua Socket Client",
        "",
        ""
    }, "\r\n")
    
    -- Send the request
    local bytes_sent, error = socket:send(request)
    if not bytes_sent then
        engine.log("Failed to send data: " .. error, 255, 0, 0, 255)
        socket:close()
        return false
    end
    
    engine.log("Sent " .. bytes_sent .. " bytes", 0, 255, 0, 255)
    return socket
end

-- Usage example
local socket = send_http_request("example.com", "/")
socket:receive
Signature: socket:receive(maxlen)

Description: Reads up to maxlen bytes from a socket.

Parameters:

maxlen (number): The maximum number of bytes to read.

Returns:

data (string): The received data as a string, or nil if the receive operation failed.

error (string): An error message if the receive operation failed.

Example:

Copy
function receive_http_response(socket, max_size)
    local response, error = socket:receive(max_size or 4096)
    
    if not response then
        engine.log("Failed to receive data: " .. error, 255, 0, 0, 255)
        return nil
    end
    
    engine.log("Received " .. #response .. " bytes", 0, 255, 0, 255)
    
    -- For HTTP responses, we might just want to show a preview
    local preview = response:sub(1, 200) .. (response:len() > 200 and "..." or "")
    engine.log("Response preview: \n" .. preview, 255, 255, 255, 255)
    
    return response
end

-- Usage example: Send a request and receive the response
local socket = send_http_request("example.com", "/")
if socket then
    local response = receive_http_response(socket, 8192)
    socket:close()
end
socket:close
Signature: socket:close()

Description: Immediately closes a socket connection.

Parameters: None

Returns: None

Example:

Copy
function http_get(hostname, path)
    local socket = connect_to_server(hostname, 80)
    if not socket then
        return nil
    end
    
    -- Send HTTP GET request
    local request = "GET " .. path .. " HTTP/1.1\r\nHost: " .. hostname .. "\r\nConnection: close\r\n\r\n"
    local sent, serr = socket:send(request)
    
    if not sent then
        engine.log("Send failed: " .. serr, 255, 0, 0, 255)
        socket:close()
        return nil
    end
    
    -- Receive response
    local response = ""
    local chunk_size = 4096
    
    while true do
        local chunk, rerr = socket:receive(chunk_size)
        
        if chunk then
            response = response .. chunk
            -- If we received less than chunk_size, we're likely done
            if #chunk < chunk_size then
                break
            end
        else
            -- Check if error is just "closed" which means the server closed connection
            if rerr ~= "closed" then
                engine.log("Receive error: " .. rerr, 255, 0, 0, 255)
            end
            break
        end
    end
    
    -- Close the socket
    socket:close()
    engine.log("Socket closed", 255, 255, 255, 255)
    
    return response
end

-- Usage example
local response = http_get("example.com", "/")
if response then
    -- Process the response...
    engine.log("Response received with " .. #response .. " bytes", 0, 255, 0, 255)
end
net.base64_encode
Signature: net.base64_encode(string)

Description: Encodes a string using Base64 encoding.

Parameters:

string (string): The string data to encode.

Returns:

string: The Base64-encoded string.

Example:

Copy
function encode_base64(text)
    local encoded = net.base64_encode(text)
    engine.log("Original: " .. text, 255, 255, 255, 255)
    engine.log("Base64 encoded: " .. encoded, 0, 255, 0, 255)
    return encoded
end

-- Usage example
local username = "user123"
local password = "secr3t"
local credentials = username .. ":" .. password
local encoded_credentials = encode_base64(credentials)

-- Construct a Basic Auth header
local auth_header = "Authorization: Basic " .. encoded_credentials
net.base64_decode
Signature: net.base64_decode(string)

Description: Decodes a Base64-encoded string.

Parameters:

string (string): The Base64-encoded string to decode.

Returns:

string: The decoded string.

Example:

Copy
function decode_base64(encoded_text)
    local decoded = net.base64_decode(encoded_text)
    engine.log("Base64 encoded: " .. encoded_text, 255, 255, 255, 255)
    engine.log("Decoded: " .. decoded, 0, 255, 0, 255)
    return decoded
end

-- Usage example
local encoded = "SGVsbG8sIHdvcmxkIQ=="
local decoded = decode_base64(encoded)  -- Should output "Hello, world!"

-- Example with an auth header
local auth_header = "Basic dXNlcjEyMzpzZWNyM3Q="
local encoded_part = auth_header:sub(7)  -- Remove "Basic " prefix
local credentials = decode_base64(encoded_part)  -- Should output "user123:secr3t"
String
Utilities for string manipulation, searching, and formatting.

Trimming and Padding
str.trim
Signature: str.trim(s)

Description: Removes leading and trailing whitespace from a string.

Parameters:

s (string): The string to trim.

Returns:

string: The trimmed string.

Example:

Copy
local text = "  Hello, world!  "
local trimmed = str.trim(text)
engine.log("Original: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Trimmed: '" .. trimmed .. "'", 255, 255, 255, 255)
-- Output: "Hello, world!"
str.ltrim
Signature: str.ltrim(s)

Description: Removes leading whitespace from a string.

Parameters:

s (string): The string to trim.

Returns:

string: The left-trimmed string.

Example:

Copy
local text = "  Hello, world!  "
local ltrimmed = str.ltrim(text)
engine.log("Original: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Left trimmed: '" .. ltrimmed .. "'", 255, 255, 255, 255)
-- Output: "Hello, world!  "
str.rtrim
Signature: str.rtrim(s)

Description: Removes trailing whitespace from a string.

Parameters:

s (string): The string to trim.

Returns:

string: The right-trimmed string.

Example:

Copy
local text = "  Hello, world!  "
local rtrimmed = str.rtrim(text)
engine.log("Original: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Right trimmed: '" .. rtrimmed .. "'", 255, 255, 255, 255)
-- Output: "  Hello, world!"
str.pad_left
Signature: str.pad_left(s, len, char)

Description: Pads the string from the left with a specified character to reach the desired length.

Parameters:

s (string): The string to pad.

len (number): The desired length.

char (string, optional): The character to use for padding. Defaults to space.

Returns:

string: The padded string.

Example:

Copy
local number = "42"
local padded = str.pad_left(number, 5, "0")
engine.log("Original: '" .. number .. "'", 255, 255, 255, 255)
engine.log("Padded: '" .. padded .. "'", 255, 255, 255, 255)
-- Output: "00042"
str.pad_right
Signature: str.pad_right(s, len, char)

Description: Pads the string from the right with a specified character to reach the desired length.

Parameters:

s (string): The string to pad.

len (number): The desired length.

char (string, optional): The character to use for padding. Defaults to space.

Returns:

string: The padded string.

Example:

Copy
local text = "Hello"
local padded = str.pad_right(text, 10, "-")
engine.log("Original: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Padded: '" .. padded .. "'", 255, 255, 255, 255)
-- Output: "Hello-----"
str.strip_prefix
Signature: str.strip_prefix(s, prefix)

Description: Removes the specified prefix from the beginning of the string if present.

Parameters:

s (string): The string to process.

prefix (string): The prefix to remove.

Returns:

string: The string with the prefix removed if it was present.

Example:

Copy
local filename = "prefix_document.txt"
local stripped = str.strip_prefix(filename, "prefix_")
engine.log("Original: '" .. filename .. "'", 255, 255, 255, 255)
engine.log("Stripped: '" .. stripped .. "'", 255, 255, 255, 255)
-- Output: "document.txt"
str.strip_suffix
Signature: str.strip_suffix(s, suffix)

Description: Removes the specified suffix from the end of the string if present.

Parameters:

s (string): The string to process.

suffix (string): The suffix to remove.

Returns:

string: The string with the suffix removed if it was present.

Example:

Copy
local filename = "document.txt"
local stripped = str.strip_suffix(filename, ".txt")
engine.log("Original: '" .. filename .. "'", 255, 255, 255, 255)
engine.log("Stripped: '" .. stripped .. "'", 255, 255, 255, 255)
-- Output: "document"
Search and Matching
str.startswith
Signature: str.startswith(s, prefix)

Description: Returns true if the string starts with the specified prefix.

Parameters:

s (string): The string to check.

prefix (string): The prefix to look for.

Returns:

boolean: true if the string starts with the prefix, false otherwise.

Example:

Copy
local text = "Hello, world!"
local result = str.startswith(text, "Hello")
engine.log("Text: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Starts with 'Hello': " .. tostring(result), 255, 255, 255, 255)
-- Output: true
str.endswith
Signature: str.endswith(s, suffix)

Description: Returns true if the string ends with the specified suffix.

Parameters:

s (string): The string to check.

suffix (string): The suffix to look for.

Returns:

boolean: true if the string ends with the suffix, false otherwise.

Example:

Copy
local text = "Hello, world!"
local result = str.endswith(text, "world!")
engine.log("Text: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Ends with 'world!': " .. tostring(result), 255, 255, 255, 255)
-- Output: true
str.contains
Signature: str.contains(s, substring)

Description: Returns true if the string contains the specified substring.

Parameters:

s (string): The string to check.

substring (string): The substring to look for.

Returns:

boolean: true if the string contains the substring, false otherwise.

Example:

Copy
local text = "Hello, world!"
local result = str.contains(text, "world")
engine.log("Text: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Contains 'world': " .. tostring(result), 255, 255, 255, 255)
-- Output: true
str.indexof
Signature: str.indexof(s, substr, start)

Description: Returns the first index of the substring in the string, or nil if not found.

Parameters:

s (string): The string to search in.

substr (string): The substring to find.

start (number, optional): The starting position for the search. Defaults to 1.

Returns:

number: The 1-based index of the first occurrence of the substring, or nil if not found.

Example:

Copy
local text = "Hello, world! Hello again!"
local index = str.indexof(text, "Hello")
local index2 = str.indexof(text, "Hello", 2)
engine.log("Text: '" .. text .. "'", 255, 255, 255, 255)
engine.log("First 'Hello' at index: " .. tostring(index), 255, 255, 255, 255) -- Output: 1
engine.log("Second 'Hello' at index: " .. tostring(index2), 255, 255, 255, 255) -- Output: 15
str.last_indexof
Signature: str.last_indexof(s, substr)

Description: Returns the last index of the substring in the string, or nil if not found.

Parameters:

s (string): The string to search in.

substr (string): The substring to find.

Returns:

number: The 1-based index of the last occurrence of the substring, or nil if not found.

Example:

Copy
local text = "Hello, world! Hello again!"
local index = str.last_indexof(text, "Hello")
engine.log("Text: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Last 'Hello' at index: " .. tostring(index), 255, 255, 255, 255)
-- Output: 15
str.count
Signature: str.count(s, substr)

Description: Counts occurrences of a substring within a string.

Parameters:

s (string): The string to search in.

substr (string): The substring to count.

Returns:

number: The number of occurrences of the substring.

Example:

Copy
local text = "one, two, three, four, one, two"
local count = str.count(text, "one")
engine.log("Text: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Count of 'one': " .. count, 255, 255, 255, 255)
-- Output: 2
str.empty
Signature: str.empty(s)

Description: Returns true if the string is empty.

Parameters:

s (string): The string to check.

Returns:

boolean: true if the string is empty, false otherwise.

Example:

Copy
local text1 = ""
local text2 = "Hello"
engine.log("Is text1 empty: " .. tostring(str.empty(text1)), 255, 255, 255, 255) -- Output: true
engine.log("Is text2 empty: " .. tostring(str.empty(text2)), 255, 255, 255, 255) -- Output: false
str.equals
Signature: str.equals(a, b)

Description: Compares two strings for equality.

Parameters:

a (string): The first string.

b (string): The second string.

Returns:

boolean: true if the strings are equal, false otherwise.

Example:

Copy
local str1 = "Hello"
local str2 = "Hello"
local str3 = "hello"
engine.log("str1 equals str2: " .. tostring(str.equals(str1, str2)), 255, 255, 255, 255) -- Output: true
engine.log("str1 equals str3: " .. tostring(str.equals(str1, str3)), 255, 255, 255, 255) -- Output: false
Modification and Replacement
str.replace
Signature: str.replace(s, from, to)

Description: Replaces all occurrences of a substring with another string.

Parameters:

s (string): The string to modify.

from (string): The substring to replace.

to (string): The replacement string.

Returns:

string: The modified string.

Example:

Copy
local text = "Hello, world! Hello, universe!"
local modified = str.replace(text, "Hello", "Hi")
engine.log("Original: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Modified: '" .. modified .. "'", 255, 255, 255, 255)
-- Output: "Hi, world! Hi, universe!"
str.repeat_str
Signature: str.repeat_str(s, count)

Description: Repeats a string a specified number of times.

Parameters:

s (string): The string to repeat.

count (number): The number of times to repeat.

Returns:

string: The repeated string.

Example:

Copy
local text = "Hello "
local repeated = str.repeat_str(text, 3)
engine.log("Original: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Repeated: '" .. repeated .. "'", 255, 255, 255, 255)
-- Output: "Hello Hello Hello "
str.reverse
Signature: str.reverse(s)

Description: Reverses a string.

Parameters:

s (string): The string to reverse.

Returns:

string: The reversed string.

Example:

Copy
local text = "Hello"
local reversed = str.reverse(text)
engine.log("Original: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Reversed: '" .. reversed .. "'", 255, 255, 255, 255)
-- Output: "olleH"
str.insert
Signature: str.insert(s, pos, substr)

Description: Inserts a substring at a specified position in the string.

Parameters:

s (string): The original string.

pos (number): The position to insert at (1-based index).

substr (string): The substring to insert.

Returns:

string: The resulting string.

Example:

Copy
local text = "Hello world!"
local modified = str.insert(text, 7, "beautiful ")
engine.log("Original: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Modified: '" .. modified .. "'", 255, 255, 255, 255)
-- Output: "Hello beautiful world!"
str.remove
Signature: str.remove(s, start, end)

Description: Removes characters from a string between start and end positions.

Parameters:

s (string): The original string.

start (number): The starting position (1-based index).

end (number): The ending position (1-based index).

Returns:

string: The resulting string.

Example:

Copy
local text = "Hello, beautiful world!"
local modified = str.remove(text, 8, 17)
engine.log("Original: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Modified: '" .. modified .. "'", 255, 255, 255, 255)
-- Output: "Hello, world!"
str.substitute
Signature: str.substitute(s, table)

Description: Replaces {key} placeholders in a string with values from a table.

Parameters:

s (string): The template string with {key} placeholders.

table (table): A table with key-value pairs for substitution.

Returns:

string: The string with placeholders replaced by their values.

Example:

Copy
local template = "Hello, {name}! You are {age} years old."
local values = {
    name = "John",
    age = 30
}
local result = str.substitute(template, values)
engine.log("Template: '" .. template .. "'", 255, 255, 255, 255)
engine.log("Result: '" .. result .. "'", 255, 255, 255, 255)
-- Output: "Hello, John! You are 30 years old."
Case and Splitting
str.upper
Signature: str.upper(s)

Description: Converts a string to uppercase.

Parameters:

s (string): The string to convert.

Returns:

string: The uppercase string.

Example:

Copy
local text = "Hello, world!"
local upper = str.upper(text)
engine.log("Original: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Uppercase: '" .. upper .. "'", 255, 255, 255, 255)
-- Output: "HELLO, WORLD!"
str.lower
Signature: str.lower(s)

Description: Converts a string to lowercase.

Parameters:

s (string): The string to convert.

Returns:

string: The lowercase string.

Example:

Copy
local text = "Hello, World!"
local lower = str.lower(text)
engine.log("Original: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Lowercase: '" .. lower .. "'", 255, 255, 255, 255)
-- Output: "hello, world!"
str.split
Signature: str.split(s, delimiter)

Description: Splits a string by a delimiter into a table of substrings.

Parameters:

s (string): The string to split.

delimiter (string): The delimiter to split by.

Returns:

table: A table of substrings.

Example:

Copy
local text = "apple,banana,orange,grape"
local parts = str.split(text, ",")
engine.log("Original: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Split into " .. #parts .. " parts:", 255, 255, 255, 255)
for i, part in ipairs(parts) do
    engine.log("  " .. i .. ": '" .. part .. "'", 255, 255, 255, 255)
end
-- Output: ["apple", "banana", "orange", "grape"]
str.slice
Signature: str.slice(s, start, end)

Description: Returns a substring based on start and end positions.

Parameters:

s (string): The original string.

start (number): The starting position (1-based index).

end (number, optional): The ending position (1-based index). Defaults to the end of the string.

Returns:

string: The extracted substring.

Example:

Copy
local text = "Hello, world!"
local slice1 = str.slice(text, 1, 5)
local slice2 = str.slice(text, 8)
engine.log("Original: '" .. text .. "'", 255, 255, 255, 255)
engine.log("Slice 1-5: '" .. slice1 .. "'", 255, 255, 255, 255) -- Output: "Hello"
engine.log("Slice 8-end: '" .. slice2 .. "'", 255, 255, 255, 255) -- Output: "world!"
UTF-8 Support
str.utf8len
Signature: str.utf8len(s)

Description: Returns the number of UTF-8 characters in a string.

Parameters:

s (string): The UTF-8 string.

Returns:

number: The number of UTF-8 characters.

Example:

Copy
local ascii = "Hello"
local unicode = ", world!"
engine.log("ASCII string: '" .. ascii .. "'", 255, 255, 255, 255)
engine.log("Length: " .. #ascii .. ", UTF-8 length: " .. str.utf8len(ascii), 255, 255, 255, 255)
engine.log("Unicode string: '" .. unicode .. "'", 255, 255, 255, 255)
engine.log("Length: " .. #unicode .. ", UTF-8 length: " .. str.utf8len(unicode), 255, 255, 255, 255)
str.utf8sub
Signature: str.utf8sub(s, start, end)

Description: Returns a UTF-8 safe substring.

Parameters:

s (string): The UTF-8 string.

start (number): The starting character position (1-based).

end (number, optional): The ending character position (1-based). Defaults to the end of the string.

Returns:

string: The UTF-8 substring.

Example:

Copy
local text = "English and  Japanese "
local substring = str.utf8sub(text, 13, 14)
engine.log("Original: '" .. text .. "'", 255, 255, 255, 255)
engine.log("UTF-8 substring (13-14): '" .. substring .. "'", 255, 255, 255, 255) -- Output: "Ja"
JSON
Parse and generate JSON data for configuration and API responses.

json.parse
Signature: json.parse(data)

Description: Parses a JSON-encoded string and returns a Lua table.

Parameters:

data (string): The JSON-encoded string to parse.

Returns:

table: A Lua table representation of the JSON data.

Example:

Copy
local json_string = '{"name": "Lua API", "version": 1.0, "features": ["json", "parsing", "serialization"]}'
local data = json.parse(json_string)

engine.log("Name: " .. data.name, 255, 255, 255, 255)
engine.log("Version: " .. data.version, 255, 255, 255, 255)
engine.log("Features count: " .. #data.features, 255, 255, 255, 255)
engine.log("First feature: " .. data.features[1], 255, 255, 255, 255)
json.stringify
Signature: json.stringify(lua_table)

Description: Converts a Lua table into a JSON-formatted string with indentation.

Parameters:

lua_table (table): The Lua table to convert to JSON.

Returns:

string: A JSON-formatted string representing the Lua table.

Example:

Copy
local data = {
    name = "Lua API",
    version = 1.5,
    features = {"json", "parsing", "serialization"},
    settings = {
        debug = true,
        max_depth = 10
    }
}

local json_string = json.stringify(data)
engine.log("Generated JSON:", 255, 255, 255, 255)
engine.log(json_string, 255, 255, 255, 255)
JSON API Usage Examples
Reading and Writing JSON Configuration
Copy
-- Function to load configuration from a JSON file
function load_config(config_file)
    if not fs.does_file_exist(config_file) then
        engine.log("Config file not found: " .. config_file, 255, 0, 0, 255)
        return nil
    end
    
    local json_string = fs.read_from_file(config_file)
    if not json_string then
        engine.log("Failed to read config file", 255, 0, 0, 255)
        return nil
    end
    
    local config = json.parse(json_string)
    engine.log("Config loaded successfully", 0, 255, 0, 255)
    return config
end

-- Function to save configuration to a JSON file
function save_config(config, config_file)
    local json_string = json.stringify(config)
    
    local success = fs.write_to_file(config_file, json_string)
    if success then
        engine.log("Config saved successfully", 0, 255, 0, 255)
    else
        engine.log("Failed to save config", 255, 0, 0, 255)
    end
    
    return success
end

-- Example usage
local config_path = "settings.json"
local config = load_config(config_path)

if not config then
    -- Create default config if none exists
    config = {
        user = {
            name = "Default User",
            theme = "dark"
        },
        app = {
            version = "1.0",
            debug = false,
            window_size = {width = 800, height = 600}
        }
    }
    
    save_config(config, config_path)
else
    -- Modify and save the config
    config.user.theme = "light"
    config.app.debug = true
    
    save_config(config, config_path)
end
Working with API Responses
Copy
-- Function to handle a network response containing JSON data
function handle_json_response(response_data, url)
    local response_string = m.read_string(response_data, 0)
    
    -- Try to parse the JSON
    local success, result = pcall(function()
        return json.parse(response_string)
    end)
    
    if not success then
        engine.log("Failed to parse JSON response: " .. tostring(result), 255, 0, 0, 255)
        return
    end
    
    -- Process the parsed JSON data
    engine.log("API Response processed successfully", 0, 255, 0, 255)
    
    if result.status == "success" then
        if result.data and result.data.items then
            engine.log("Received " .. #result.data.items .. " items", 255, 255, 255, 255)
            
            -- Process each item
            for i, item in ipairs(result.data.items) do
                engine.log("Item " .. i .. ": " .. item.name, 255, 255, 255, 255)
            end
        end
    else
        engine.log("API Error: " .. (result.error or "Unknown error"), 255, 0, 0, 255)
    end
end

-- Register the response handler
engine.register_on_network_callback(handle_json_response)

-- Send a request to an API that returns JSON
function request_api_data()
    local url = "https://api.example.com/data"
    local headers = "Content-Type: application/json\r\nUser-Agent: LuaAPI/1.0"
    
    net.send_request(url, headers)
    engine.log("Request sent to: " .. url, 255, 255, 255, 255)
end

-- Call the function to initiate the request
request_api_data()
Creating Complex JSON Structures
Copy
-- Create a complex data structure
local game_state = {
    player = {
        name = "Player1",
        position = {x = 100.5, y = 200.75, z = 50.25},
        health = 85,
        inventory = {
            {id = "sword", level = 2, enchanted = true},
            {id = "shield", level = 1, enchanted = false},
            {id = "potion", count = 5}
        }
    },
    world = {
        name = "Test World",
        seed = 12345678,
        dimensions = {
            overworld = {loaded = true, entities = 42},
            nether = {loaded = false, entities = 0}
        }
    },
    settings = {
        graphics = "high",
        sound = true,
        controls = {
            forward = "W",
            backward = "S",
            left = "A",
            right = "D",
            jump = "Space"
        }
    },
    timestamp = time.unix()
}

-- Convert to JSON string
local json_string = json.stringify(game_state)

-- Save to file
fs.write_to_file("game_state.json", json_string)
engine.log("Game state saved to JSON file", 0, 255, 0, 255)

-- Later, load the saved state
if fs.does_file_exist("game_state.json") then
    local saved_json = fs.read_from_file("game_state.json")
    local saved_state = json.parse(saved_json)
    
    engine.log("Loaded game state for player: " .. saved_state.player.name, 255, 255, 255, 255)
    engine.log("Player position: (" .. 
        saved_state.player.position.x .. ", " .. 
        saved_state.player.position.y .. ", " .. 
        saved_state.player.position.z .. ")", 255, 255, 255, 255)
    engine.log("Player has " .. #saved_state.player.inventory .. " items", 255, 255, 255, 255)
end
Math
Extra math utilities: clamping, interpolation, rounding, and more.

Core Functions
math.clamp
Signature: math.clamp(x, min, max)

Description: Restricts a value to be within a specified range.

Parameters:

x (number): The value to clamp.

min (number): The minimum allowable value.

max (number): The maximum allowable value.

Returns:

number: The clamped value (between min and max).

Example:

Copy
local health = -10
local clamped_health = math.clamp(health, 0, 100)
engine.log("Original: " .. health, 255, 255, 255, 255)
engine.log("Clamped: " .. clamped_health, 255, 255, 255, 255)
-- Output: Clamped: 0

local heat = 120
local clamped_heat = math.clamp(heat, 0, 100)
engine.log("Original: " .. heat, 255, 255, 255, 255)
engine.log("Clamped: " .. clamped_heat, 255, 255, 255, 255)
-- Output: Clamped: 100
math.lerp
Signature: math.lerp(a, b, t)

Description: Linearly interpolates between two values by a factor t.

Parameters:

a (number): The start value.

b (number): The end value.

t (number): The interpolation factor (usually between 0 and 1).

Returns:

number: The interpolated value.

Example:

Copy
local start = 0
local end_val = 100
local halfway = math.lerp(start, end_val, 0.5)
engine.log("Start: " .. start, 255, 255, 255, 255)
engine.log("End: " .. end_val, 255, 255, 255, 255)
engine.log("Halfway: " .. halfway, 255, 255, 255, 255)
-- Output: Halfway: 50

-- Create a smooth transition effect
local function animate(current, target, speed)
    return math.lerp(current, target, speed)
end

local position = 0
local target = 100
position = animate(position, target, 0.1)  -- Move 10% of the remaining distance
engine.log("New position: " .. position, 255, 255, 255, 255)
math.round
Signature: math.round(x)

Description: Rounds a number to the nearest integer.

Parameters:

x (number): The number to round.

Returns:

number: The rounded integer.

Example:

Copy
local value1 = 3.2
local value2 = 3.7
local value3 = 3.5
engine.log(value1 .. " rounded: " .. math.round(value1), 255, 255, 255, 255)
engine.log(value2 .. " rounded: " .. math.round(value2), 255, 255, 255, 255)
engine.log(value3 .. " rounded: " .. math.round(value3), 255, 255, 255, 255)
-- Output: 3.2 rounded: 3
-- Output: 3.7 rounded: 4
-- Output: 3.5 rounded: 4
math.round_up
Signature: math.round_up(x)

Description: Rounds a number upward (ceiling function).

Parameters:

x (number): The number to round up.

Returns:

number: The rounded up integer.

Example:

Copy
local value1 = 3.2
local value2 = 3.0
engine.log(value1 .. " rounded up: " .. math.round_up(value1), 255, 255, 255, 255)
engine.log(value2 .. " rounded up: " .. math.round_up(value2), 255, 255, 255, 255)
-- Output: 3.2 rounded up: 4
-- Output: 3.0 rounded up: 3
math.round_down
Signature: math.round_down(x)

Description: Rounds a number downward (floor function).

Parameters:

x (number): The number to round down.

Returns:

number: The rounded down integer.

Example:

Copy
local value1 = 3.7
local value2 = 3.0
engine.log(value1 .. " rounded down: " .. math.round_down(value1), 255, 255, 255, 255)
engine.log(value2 .. " rounded down: " .. math.round_down(value2), 255, 255, 255, 255)
-- Output: 3.7 rounded down: 3
-- Output: 3.0 rounded down: 3
math.round_to_nearest
Signature: math.round_to_nearest(x, step)

Description: Rounds a number to the nearest multiple of step.

Parameters:

x (number): The number to round.

step (number): The step size to round to.

Returns:

number: The rounded value.

Example:

Copy
local value = 42.32
engine.log(value .. " rounded to nearest 5: " .. math.round_to_nearest(value, 5), 255, 255, 255, 255)
engine.log(value .. " rounded to nearest 0.1: " .. math.round_to_nearest(value, 0.1), 255, 255, 255, 255)
-- Output: 42.32 rounded to nearest 5: 40
-- Output: 42.32 rounded to nearest 0.1: 42.3
math.sign
Signature: math.sign(x)

Description: Returns the sign of a number as -1, 0, or 1.

Parameters:

x (number): The number to get the sign of.

Returns:

number: -1 if negative, 0 if zero, 1 if positive.

Example:

Copy
local value1 = -42
local value2 = 0
local value3 = 128
engine.log("Sign of " .. value1 .. ": " .. math.sign(value1), 255, 255, 255, 255)
engine.log("Sign of " .. value2 .. ": " .. math.sign(value2), 255, 255, 255, 255)
engine.log("Sign of " .. value3 .. ": " .. math.sign(value3), 255, 255, 255, 255)
-- Output: Sign of -42: -1
-- Output: Sign of 0: 0
-- Output: Sign of 128: 1
math.map
Signature: math.map(x, in_min, in_max, out_min, out_max)

Description: Maps a value from one range to another.

Parameters:

x (number): The value to map.

in_min (number): The minimum of the input range.

in_max (number): The maximum of the input range.

out_min (number): The minimum of the output range.

out_max (number): The maximum of the output range.

Returns:

number: The mapped value.

Example:

Copy
local percent = 75
local health = math.map(percent, 0, 100, 0, 1000)
engine.log(percent .. "% maps to " .. health .. " health points", 255, 255, 255, 255)
-- Output: 75% maps to 750 health points

-- Convert a value from one range to another
local temperature_celsius = 25
local temperature_fahrenheit = math.map(temperature_celsius, 0, 100, 32, 212)
engine.log(temperature_celsius .. "C = " .. temperature_fahrenheit .. "F", 255, 255, 255, 255)
-- Output: 25C = 77F
math.saturate
Signature: math.saturate(x)

Description: Clamps a value between 0 and 1.

Parameters:

x (number): The value to saturate.

Returns:

number: The saturated value (between 0 and 1).

Example:

Copy
local value1 = -0.5
local value2 = 0.5
local value3 = 1.5
engine.log(value1 .. " saturated: " .. math.saturate(value1), 255, 255, 255, 255)
engine.log(value2 .. " saturated: " .. math.saturate(value2), 255, 255, 255, 255)
engine.log(value3 .. " saturated: " .. math.saturate(value3), 255, 255, 255, 255)
-- Output: -0.5 saturated: 0
-- Output: 0.5 saturated: 0.5
-- Output: 1.5 saturated: 1
Validation & Checks
math.is_nan
Signature: math.is_nan(x)

Description: Returns true if x is NaN (Not a Number).

Parameters:

x (number): The value to check.

Returns:

boolean: true if x is NaN, false otherwise.

Example:

Copy
local value1 = 0/0  -- NaN
local value2 = 42
engine.log("Is " .. tostring(value1) .. " NaN? " .. tostring(math.is_nan(value1)), 255, 255, 255, 255)
engine.log("Is " .. value2 .. " NaN? " .. tostring(math.is_nan(value2)), 255, 255, 255, 255)
-- Output: Is nan NaN? true
-- Output: Is 42 NaN? false
math.is_inf
Signature: math.is_inf(x)

Description: Returns true if x is infinite.

Parameters:

x (number): The value to check.

Returns:

boolean: true if x is infinite, false otherwise.

Example:

Copy
local value1 = 1/0  -- Infinity
local value2 = 42
engine.log("Is " .. tostring(value1) .. " Infinite? " .. tostring(math.is_inf(value1)), 255, 255, 255, 255)
engine.log("Is " .. value2 .. " Infinite? " .. tostring(math.is_inf(value2)), 255, 255, 255, 255)
-- Output: Is inf Infinite? true
-- Output: Is 42 Infinite? false
Interpolation & Range Tools
math.smoothstep
Signature: math.smoothstep(edge0, edge1, x)

Description: Performs smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1.

Parameters:

edge0 (number): The lower edge of the interpolation range.

edge1 (number): The upper edge of the interpolation range.

x (number): The input value to interpolate.

Returns:

number: The smoothly interpolated value (0 to 1).

Example:

Copy
local value = 0.5
local smooth = math.smoothstep(0, 1, value)
engine.log("Value: " .. value, 255, 255, 255, 255)
engine.log("Smoothstep: " .. smooth, 255, 255, 255, 255)
-- The output will be a value that approaches 0.5 but with a smoothed curve

-- Create a smooth fade effect
local function smooth_fade(current, min, max)
    return math.smoothstep(min, max, current)
end

local position = 0.3
local fade_value = smooth_fade(position, 0, 1)
engine.log("Fade value at position " .. position .. ": " .. fade_value, 255, 255, 255, 255)
math.inverse_lerp
Signature: math.inverse_lerp(a, b, x)

Description: Computes the normalized parameter t where x lies between a and b.

Parameters:

a (number): The start of the range.

b (number): The end of the range.

x (number): The value to find the parameter for.

Returns:

number: The normalized parameter t (usually between 0 and 1).

Example:

Copy
local min = 100
local max = 200
local value = 150
local t = math.inverse_lerp(min, max, value)
engine.log("Value " .. value .. " is at position " .. t .. " between " .. min .. " and " .. max, 255, 255, 255, 255)
-- Output: Value 150 is at position 0.5 between 100 and 200

-- Find percentage of health
local max_health = 1000
local current_health = 750
local health_percent = math.inverse_lerp(0, max_health, current_health)
engine.log("Health: " .. (health_percent * 100) .. "%", 255, 255, 255, 255)
-- Output: Health: 75%
math.fract
Signature: math.fract(x)

Description: Returns the fractional part of x.

Parameters:

x (number): The value to get the fractional part of.

Returns:

number: The fractional part of x (always between 0 and 1).

Example:

Copy
local value1 = 3.75
local value2 = -2.25
engine.log("Fractional part of " .. value1 .. ": " .. math.fract(value1), 255, 255, 255, 255)
engine.log("Fractional part of " .. value2 .. ": " .. math.fract(value2), 255, 255, 255, 255)
-- Output: Fractional part of 3.75: 0.75
-- Output: Fractional part of -2.25: 0.75
math.wrap
Signature: math.wrap(x, min, max)

Description: Wraps a value so it stays within the specified range.

Parameters:

x (number): The value to wrap.

min (number): The minimum of the range.

max (number): The maximum of the range.

Returns:

number: The wrapped value.

Example:

Copy
local angle = 370  -- Degrees (past 360)
local wrapped_angle = math.wrap(angle, 0, 360)
engine.log("Original angle: " .. angle .. "", 255, 255, 255, 255)
engine.log("Wrapped angle: " .. wrapped_angle .. "", 255, 255, 255, 255)
-- Output: Wrapped angle: 10

-- Wrap time of day (in hours)
local time = 25  -- 25 hours
local day_time = math.wrap(time, 0, 24)
engine.log("Time: " .. day_time .. ":00", 255, 255, 255, 255)
-- Output: Time: 1:00
Math API Usage Examples
Smooth Movement
Copy
-- Create a smooth movement system
local function smooth_move(current, target, delta_time, speed)
    local t = math.clamp(delta_time * speed, 0, 1)
    return math.lerp(current, target, t)
end

local position = 0
local target = 100
local delta_time = 0.16  -- Assuming 60 FPS
local speed = 2

position = smooth_move(position, target, delta_time, speed)
engine.log("New position: " .. position, 255, 255, 255, 255)
Health Bar Colors
Copy
-- Get color for health bar based on percentage
local function get_health_color(health_percent)
    -- Red when low, yellow in middle, green when high
    local r, g, b
    
    if health_percent < 0.5 then
        -- Interpolate from red to yellow (0% to 50%)
        local t = math.inverse_lerp(0, 0.5, health_percent)
        r = 255
        g = math.round(math.lerp(0, 255, t))
        b = 0
    else
        -- Interpolate from yellow to green (50% to 100%)
        local t = math.inverse_lerp(0.5, 1, health_percent)
        r = math.round(math.lerp(255, 0, t))
        g = 255
        b = 0
    end
    
    return r, g, b
end

local health = 75  -- percentage
local r, g, b = get_health_color(health / 100)
engine.log("Health color for " .. health .. "%: RGB(" .. r .. ", " .. g .. ", " .. b .. ")", r, g, b, 255)
Circular Motion
Copy
-- Create circular motion using math functions
local function circular_position(center_x, center_y, radius, angle_degrees)
    local angle_rad = angle_degrees * (math.pi / 180)
    local x = center_x + radius * math.cos(angle_rad)
    local y = center_y + radius * math.sin(angle_rad)
    return math.round(x), math.round(y)
end

local center_x, center_y = 400, 300
local radius = 100
local angle = 45  -- degrees

local x, y = circular_position(center_x, center_y, radius, angle)
engine.log("Position at " .. angle .. ": (" .. x .. ", " .. y .. ")", 255, 255, 255, 255)
Time
Work with timestamps, date formatting, and time calculations.

Current Time and Formatting
time.unix
Signature: time.unix()

Description: Returns the current Unix timestamp in seconds.

Parameters: None

Returns:

number: The current Unix timestamp (seconds since January 1, 1970).

Example:

Copy
local current_timestamp = time.unix()
engine.log("Current Unix timestamp: " .. current_timestamp, 255, 255, 255, 255)
time.unix_ms
Signature: time.unix_ms()

Description: Returns the current Unix timestamp in milliseconds.

Parameters: None

Returns:

number: The current Unix timestamp in milliseconds.

Example:

Copy
local current_ms_timestamp = time.unix_ms()
engine.log("Current Unix timestamp (ms): " .. current_ms_timestamp, 255, 255, 255, 255)

-- Calculate elapsed time with millisecond precision
local start_time = time.unix_ms()
-- ... perform some operation ...
local end_time = time.unix_ms()
local elapsed_ms = end_time - start_time
engine.log("Operation took " .. elapsed_ms .. " milliseconds", 255, 255, 255, 255)
time.now_utc
Signature: time.now_utc()

Description: Returns the current UTC time as a formatted string.

Parameters: None

Returns:

string: The current UTC time in the format "YYYY-MM-DD HH:MM:SS".

Example:

Copy
local utc_time = time.now_utc()
engine.log("Current UTC time: " .. utc_time, 255, 255, 255, 255)
time.now_local
Signature: time.now_local()

Description: Returns the current local time as a formatted string.

Parameters: None

Returns:

string: The current local time in the format "YYYY-MM-DD HH:MM:SS".

Example:

Copy
local local_time = time.now_local()
engine.log("Current local time: " .. local_time, 255, 255, 255, 255)
time.format
Signature: time.format(timestamp)

Description: Converts a Unix timestamp to a local date-time string.

Parameters:

timestamp (number): The Unix timestamp to format.

Returns:

string: The formatted date-time string in the format "YYYY-MM-DD HH:MM:SS".

Example:

Copy
local timestamp = time.unix()
local formatted_time = time.format(timestamp)
engine.log("Formatted time: " .. formatted_time, 255, 255, 255, 255)

-- Format a past timestamp
local past_timestamp = timestamp - 86400 -- 24 hours ago
local yesterday = time.format(past_timestamp)
engine.log("24 hours ago: " .. yesterday, 255, 255, 255, 255)
time.format_custom
Signature: time.format_custom(timestamp, format)

Description: Formats a timestamp using a custom format string (in UTC).

Parameters:

timestamp (number): The Unix timestamp to format.

format (string): The format string using strftime() syntax.

Returns:

string: The formatted date-time string according to the specified format.

Example:

Copy
local timestamp = time.unix()

-- Format with various patterns
local date_only = time.format_custom(timestamp, "%Y-%m-%d")
local time_only = time.format_custom(timestamp, "%H:%M:%S")
local custom = time.format_custom(timestamp, "%A, %B %d, %Y at %I:%M %p")

engine.log("Date only: " .. date_only, 255, 255, 255, 255)
engine.log("Time only: " .. time_only, 255, 255, 255, 255)
engine.log("Custom format: " .. custom, 255, 255, 255, 255)
Comparison and Difference
time.delta
Signature: time.delta(t1, t2)

Description: Returns the difference between two timestamps in seconds.

Parameters:

t1 (number): The first timestamp.

t2 (number): The second timestamp.

Returns:

number: The difference between t2 and t1 in seconds (t2 - t1).

Example:

Copy
local start_time = time.unix()
-- ... perform some operation ...
local end_time = time.unix()

local elapsed = time.delta(start_time, end_time)
engine.log("Operation took " .. elapsed .. " seconds", 255, 255, 255, 255)
time.compare
Signature: time.compare(t1, t2)

Description: Compares two timestamps and returns their relative order.

Parameters:

t1 (number): The first timestamp.

t2 (number): The second timestamp.

Returns:

number: -1 if t1 < t2, 0 if t1 == t2, or 1 if t1 > t2.

Example:

Copy
local now = time.unix()
local then = now - 3600 -- 1 hour ago

local result = time.compare(now, then)
if result > 0 then
    engine.log("Now is later than the past timestamp", 255, 255, 255, 255)
elseif result < 0 then
    engine.log("Now is earlier than the past timestamp", 255, 255, 255, 255)
else
    engine.log("Timestamps are equal", 255, 255, 255, 255)
end
time.same_day
Signature: time.same_day(t1, t2)

Description: Returns true if both timestamps fall on the same calendar day.

Parameters:

t1 (number): The first timestamp.

t2 (number): The second timestamp.

Returns:

boolean: true if the timestamps are on the same calendar day, false otherwise.

Example:

Copy
local now = time.unix()
local earlier_today = now - 3600 -- 1 hour ago
local yesterday = now - 86400 -- 24 hours ago

if time.same_day(now, earlier_today) then
    engine.log("Now and 1 hour ago are on the same day", 255, 255, 255, 255)
else
    engine.log("Now and 1 hour ago are on different days", 255, 255, 255, 255)
end

if time.same_day(now, yesterday) then
    engine.log("Now and yesterday are on the same day", 255, 255, 255, 255)
else
    engine.log("Now and yesterday are on different days", 255, 255, 255, 255)
end
time.diff_table
Signature: time.diff_table(t1, t2)

Description: Returns a breakdown of the time difference in days, hours, minutes, and seconds.

Parameters:

t1 (number): The first timestamp.

t2 (number): The second timestamp.

Returns:

table: A table with the following fields:

days (number): Number of days difference.

hours (number): Number of hours difference (0-23).

minutes (number): Number of minutes difference (0-59).

seconds (number): Number of seconds difference (0-59).

total_seconds (number): Total difference in seconds.

Example:

Copy
local now = time.unix()
local past = now - 123456 -- Some time in the past

local diff = time.diff_table(past, now)
engine.log("Time difference:", 255, 255, 255, 255)
engine.log("  Days: " .. diff.days, 255, 255, 255, 255)
engine.log("  Hours: " .. diff.hours, 255, 255, 255, 255)
engine.log("  Minutes: " .. diff.minutes, 255, 255, 255, 255)
engine.log("  Seconds: " .. diff.seconds, 255, 255, 255, 255)
engine.log("  Total seconds: " .. diff.total_seconds, 255, 255, 255, 255)
time.between
Signature: time.between(now, start, end)

Description: Checks if a timestamp falls within a time range.

Parameters:

now (number): The timestamp to check.

start (number): The start of the time range.

end (number): The end of the time range.

Returns:

boolean: true if now falls between start and end (inclusive), false otherwise.

Example:

Copy
local now = time.unix()
local start = now - 3600 -- 1 hour ago
local end_time = now + 3600 -- 1 hour from now

if time.between(now, start, end_time) then
    engine.log("Current time is within the specified range", 255, 255, 255, 255)
else
    engine.log("Current time is outside the specified range", 255, 255, 255, 255)
end

-- Check if a specific timestamp is in an event window
local event_start = time.timestamp_utc(2023, 12, 24, 0, 0, 0) -- Christmas Eve
local event_end = time.timestamp_utc(2023, 12, 26, 0, 0, 0) -- Day after Christmas
if time.between(now, event_start, event_end) then
    engine.log("Christmas event is active!", 255, 0, 0, 255)
end
Date Info and Conversion
time.weekday
Signature: time.weekday(timestamp)

Description: Gets the day of the week from a timestamp.

Parameters:

timestamp (number): The Unix timestamp.

Returns:

number: The day of the week (0 = Sunday, 1 = Monday, ..., 6 = Saturday).

Example:

Copy
local now = time.unix()
local day = time.weekday(now)
local day_names = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}

engine.log("Today is " .. day_names[day+1], 255, 255, 255, 255)
time.day_of_year
Signature: time.day_of_year(timestamp)

Description: Returns the day number within the year (1-366).

Parameters:

timestamp (number): The Unix timestamp.

Returns:

number: The day of the year (1-366).

Example:

Copy
local now = time.unix()
local day_num = time.day_of_year(now)
engine.log("Day of year: " .. day_num, 255, 255, 255, 255)

-- Calculate days left in the year
local year_info = time.year_month_day(now)
local days_in_year = time.is_leap_year(now) and 366 or 365
local days_left = days_in_year - day_num
engine.log("Days left in " .. year_info.year .. ": " .. days_left, 255, 255, 255, 255)
time.year_month_day
Signature: time.year_month_day(timestamp)

Description: Returns a table with year, month, and day components.

Parameters:

timestamp (number): The Unix timestamp.

Returns:

table: A table with the following fields:

year (number): The year.

month (number): The month (1-12).

day (number): The day of the month (1-31).

Example:

Copy
local now = time.unix()
local date = time.year_month_day(now)

engine.log("Current date:", 255, 255, 255, 255)
engine.log("  Year: " .. date.year, 255, 255, 255, 255)
engine.log("  Month: " .. date.month, 255, 255, 255, 255)
engine.log("  Day: " .. date.day, 255, 255, 255, 255)
time.is_weekend
Signature: time.is_weekend(timestamp)

Description: Returns true if the timestamp falls on Saturday or Sunday.

Parameters:

timestamp (number): The Unix timestamp.

Returns:

boolean: true if the day is Saturday or Sunday, false otherwise.

Example:

Copy
local now = time.unix()
if time.is_weekend(now) then
    engine.log("It's the weekend!", 0, 255, 0, 255)
else
    engine.log("It's a weekday", 255, 255, 255, 255)
end
time.is_leap_year
Signature: time.is_leap_year(timestamp)

Description: Checks if the year of the timestamp is a leap year.

Parameters:

timestamp (number): The Unix timestamp.

Returns:

boolean: true if it's a leap year, false otherwise.

Example:

Copy
local now = time.unix()
local date = time.year_month_day(now)

if time.is_leap_year(now) then
    engine.log(date.year .. " is a leap year", 0, 255, 0, 255)
else
    engine.log(date.year .. " is not a leap year", 255, 255, 255, 255)
end
time.days_in_month
Signature: time.days_in_month(year, month)

Description: Returns the number of days in a given month and year.

Parameters:

year (number): The year.

month (number): The month (1-12).

Returns:

number: The number of days in the specified month (28-31).

Example:

Copy
local now = time.unix()
local date = time.year_month_day(now)
local days = time.days_in_month(date.year, date.month)

engine.log("There are " .. days .. " days in month " .. date.month .. " of " .. date.year, 255, 255, 255, 255)

-- Check days in February for the current year
local feb_days = time.days_in_month(date.year, 2)
engine.log("February " .. date.year .. " has " .. feb_days .. " days", 255, 255, 255, 255)
time.timestamp_utc
Signature: time.timestamp_utc(year, month, day, hour, min, sec)

Description: Converts a date and time to a UTC Unix timestamp.

Parameters:

year (number): The year.

month (number): The month (1-12).

day (number): The day of the month (1-31).

hour (number): The hour (0-23).

min (number): The minute (0-59).

sec (number): The second (0-59).

Returns:

number: The corresponding Unix timestamp.

Example:

Copy
-- Create a timestamp for a specific date and time (UTC)
local christmas_eve = time.timestamp_utc(2023, 12, 24, 20, 0, 0) -- 8:00 PM UTC on Dec 24, 2023
engine.log("Christmas Eve timestamp: " .. christmas_eve, 255, 255, 255, 255)
engine.log("Formatted: " .. time.format(christmas_eve), 255, 255, 255, 255)

-- Create a timestamp for an upcoming event
local event_year = 2024
local event_timestamp = time.timestamp_utc(event_year, 7, 4, 18, 0, 0) -- July 4th at 6:00 PM UTC
local now = time.unix()

if now < event_timestamp then
    local diff = time.diff_table(now, event_timestamp)
    engine.log("Upcoming event in " .. diff.days .. " days, " .. diff.hours .. " hours", 255, 255, 255, 255)
end
time.add_days
Signature: time.add_days(timestamp, days)

Description: Adds (or subtracts) days to a timestamp.

Parameters:

timestamp (number): The Unix timestamp.

days (number): The number of days to add (can be negative).

Returns:

number: The new timestamp.

Example:

Copy
local now = time.unix()
local tomorrow = time.add_days(now, 1)
local yesterday = time.add_days(now, -1)
local next_week = time.add_days(now, 7)

engine.log("Now: " .. time.format(now), 255, 255, 255, 255)
engine.log("Tomorrow: " .. time.format(tomorrow), 255, 255, 255, 255)
engine.log("Yesterday: " .. time.format(yesterday), 255, 255, 255, 255)
engine.log("Next week: " .. time.format(next_week), 255, 255, 255, 255)
time.start_of_day
Signature: time.start_of_day(timestamp)

Description: Returns a timestamp for 00:00:00 of the day.

Parameters:

timestamp (number): The Unix timestamp.

Returns:

number: A timestamp for the start of the day (midnight 00:00:00).

Example:

Copy
local now = time.unix()
local day_start = time.start_of_day(now)

engine.log("Current time: " .. time.format(now), 255, 255, 255, 255)
engine.log("Start of day: " .. time.format(day_start), 255, 255, 255, 255)

-- Check if a value was reset today
local last_reset = 1672531200 -- Example: January 1, 2023
local today_start = time.start_of_day(now)

if last_reset < today_start then
    engine.log("Value needs to be reset (last reset was before today)", 255, 0, 0, 255)
else
    engine.log("Value already reset today", 0, 255, 0, 255)
end
time.end_of_day
Signature: time.end_of_day(timestamp)

Description: Returns a timestamp for 23:59:59 of the day.

Parameters:

timestamp (number): The Unix timestamp.

Returns:

number: A timestamp for the end of the day (23:59:59).

Example:

Copy
local now = time.unix()
local day_end = time.end_of_day(now)

engine.log("Current time: " .. time.format(now), 255, 255, 255, 255)
engine.log("End of day: " .. time.format(day_end), 255, 255, 255, 255)

-- Calculate seconds until the end of the day
local seconds_left = time.delta(now, day_end)
engine.log("Seconds until end of day: " .. seconds_left, 255, 255, 255, 255)
Tables and Structures
time.to_table
Signature: time.to_table(timestamp)

Description: Converts a timestamp to a local date-time table.

Parameters:

timestamp (number): The Unix timestamp.

Returns:

table: A table with the following fields:

year (number): The year.

month (number): The month (1-12).

day (number): The day of the month (1-31).

hour (number): The hour (0-23).

min (number): The minute (0-59).

sec (number): The second (0-59).

wday (number): The day of the week (0 = Sunday, 1 = Monday, ...).

yday (number): The day of the year (1-366).

isdst (boolean): true if Daylight Saving Time is in effect.

Example:

Copy
local now = time.unix()
local time_table = time.to_table(now)

engine.log("Time table components:", 255, 255, 255, 255)
engine.log("  Year: " .. time_table.year, 255, 255, 255, 255)
engine.log("  Month: " .. time_table.month, 255, 255, 255, 255)
engine.log("  Day: " .. time_table.day, 255, 255, 255, 255)
engine.log("  Hour: " .. time_table.hour, 255, 255, 255, 255)
engine.log("  Minute: " .. time_table.min, 255, 255, 255, 255)
engine.log("  Second: " .. time_table.sec, 255, 255, 255, 255)
engine.log("  Weekday: " .. time_table.wday, 255, 255, 255, 255)
engine.log("  Day of year: " .. time_table.yday, 255, 255, 255, 255)
engine.log("  DST active: " .. tostring(time_table.isdst), 255, 255, 255, 255)
time.from_table
Signature: time.from_table(table)

Description: Converts a local date-time table to a timestamp.

Parameters:

table (table): A table with date-time components (year, month, day, hour, min, sec).

Returns:

number: The corresponding Unix timestamp.

Example:

Copy
-- Create a time table manually
local date_time = {
    year = 2023,
    month = 12,
    day = 31,
    hour = 23,
    min = 59,
    sec = 59
}

local timestamp = time.from_table(date_time)
engine.log("New Year's Eve 2023 timestamp: " .. timestamp, 255, 255, 255, 255)
engine.log("Formatted: " .. time.format(timestamp), 255, 255, 255, 255)

-- Modify an existing time table
local now = time.unix()
local now_table = time.to_table(now)

-- Set to noon today
now_table.hour = 12
now_table.min = 0
now_table.sec = 0

local noon_timestamp = time.from_table(now_table)
engine.log("Today at noon: " .. time.format(noon_timestamp), 255, 255, 255, 255)
time.to_utc_table
Signature: time.to_utc_table(timestamp)

Description: Converts a timestamp to a UTC date-time table.

Parameters:

timestamp (number): The Unix timestamp.

Returns:

table: A table with UTC date-time components (year, month, day, etc.).

Example:

Copy
local now = time.unix()
local utc_table = time.to_utc_table(now)
local local_table = time.to_table(now)

engine.log("UTC time: " .. utc_table.hour .. ":" .. utc_table.min .. ":" .. utc_table.sec, 255, 255, 255, 255)
engine.log("Local time: " .. local_table.hour .. ":" .. local_table.min .. ":" .. local_table.sec, 255, 255, 255, 255)
time.from_utc_table
Signature: time.from_utc_table(table)

Description: Converts a UTC date-time table to a timestamp.

Parameters:

table (table): A table with UTC date-time components.

Returns:

number: The corresponding Unix timestamp.

Example:

Copy
-- Create a UTC time table
local utc_date_time = {
    year = 2023,
    month = 1,
    day = 1,
    hour = 0,
    min = 0,
    sec = 0
}

local timestamp = time.from_utc_table(utc_date_time)
engine.log("New Year 2023 UTC timestamp: " .. timestamp, 255, 255, 255, 255)
engine.log("Formatted in local time: " .. time.format(timestamp), 255, 255, 255, 255)
Validation and Info
time.is_valid
Signature: time.is_valid(timestamp)

Description: Checks if a timestamp is valid.

Parameters:

timestamp (number): The Unix timestamp to check.

Returns:

boolean: true if the timestamp is valid, false otherwise.

Example:

Copy
local valid_time = time.unix()
local invalid_time = -62167219200 -- Before Unix epoch minimum

if time.is_valid(valid_time) then
    engine.log("Current time is valid", 0, 255, 0, 255)
else
    engine.log("Current time is invalid", 255, 0, 0, 255)
end

if time.is_valid(invalid_time) then
    engine.log("Test time is valid", 0, 255, 0, 255)
else
    engine.log("Test time is invalid", 255, 0, 0, 255)
end
time.is_dst
Signature: time.is_dst(timestamp)

Description: Returns true if the timestamp is in Daylight Saving Time.

Parameters:

timestamp (number): The Unix timestamp.

Returns:

boolean: true if DST is in effect, false otherwise.

Example:

Copy
local now = time.unix()
if time.is_dst(now) then
    engine.log("Daylight Saving Time is currently in effect", 0, 255, 0, 255)
else
    engine.log("Standard Time is currently in effect", 255, 255, 255, 255)
end

-- Check DST for different times of year
local summer = time.timestamp_utc(2023, 7, 1, 12, 0, 0)
local winter = time.timestamp_utc(2023, 1, 1, 12, 0, 0)

engine.log("July 1: DST = " .. tostring(time.is_dst(summer)), 255, 255, 255, 255)
engine.log("January 1: DST = " .. tostring(time.is_dst(winter)), 255, 255, 255, 255)
time.utc_offset
Signature: time.utc_offset()

Description: Returns the local time offset from UTC in seconds.

Parameters: None

Returns:

number: The offset in seconds from UTC for the local time zone.

Example:

Copy
local offset_seconds = time.utc_offset()
local offset_hours = offset_seconds / 3600

engine.log("UTC offset: " .. offset_seconds .. " seconds", 255, 255, 255, 255)
engine.log("UTC offset: " .. offset_hours .. " hours", 255, 255, 255, 255)
time.get_timezone
Signature: time.get_timezone()

Description: Returns the time zone string (e.g., "UTC-03:00").

Parameters: None

Returns:

string: The time zone string.

Example:

Copy
local timezone = time.get_timezone()
engine.log("Current timezone: " .. timezone, 255, 255, 255, 255)
Utilities and Constants
time.seconds_to_hhmmss
Signature: time.seconds_to_hhmmss(seconds)

Description: Converts seconds to a formatted HH:MM:SS string.

Parameters:

seconds (number): The number of seconds.

Returns:

string: The formatted time string in HH:MM:SS format.

Example:

Copy
local seconds = 3661 -- 1 hour, 1 minute, 1 second
local formatted = time.seconds_to_hhmmss(seconds)
engine.log(seconds .. " seconds = " .. formatted, 255, 255, 255, 255)

-- Use in a countdown
local remaining = 7200 -- 2 hours
engine.log("Time remaining: " .. time.seconds_to_hhmmss(remaining), 255, 255, 255, 255)
Time Constants
The Time API provides several useful constants:

time.SECONDS_PER_MINUTE - 60

time.SECONDS_PER_HOUR - 3600

time.SECONDS_PER_DAY - 86400

time.DAYS_PER_WEEK - 7

time.WEEKDAY_NAMES - Table of weekday names (1 = Sunday, 7 = Saturday)

time.MONTH_NAMES - Table of month names (1 = January, 12 = December)

time.MONTH_DAYS - Days in each month (non-leap year)

time.MONTH_DAYS_LEAP - Days in each month (leap year)

time.MONTH_NAME_TO_INDEX - Maps month names to numeric indexes

Example:

Copy
-- Use time constants for calculations
local minutes = 42
local seconds = minutes * time.SECONDS_PER_MINUTE
engine.log(minutes .. " minutes = " .. seconds .. " seconds", 255, 255, 255, 255)

local now = time.unix()
local weekday_idx = time.weekday(now) + 1 -- Adjust from 0-based to 1-based
local month_idx = time.to_table(now).month

engine.log("Today is " .. time.WEEKDAY_NAMES[weekday_idx], 255, 255, 255, 255)
engine.log("Current month is " .. time.MONTH_NAMES[month_idx], 255, 255, 255, 255)

-- Convert month name to index
local month_name = "July"
local month_num = time.MONTH_NAME_TO_INDEX[month_name]
engine.log(month_name .. " is month #" .. month_num, 255, 255, 255, 255)
Vector Types (vec2, vec3, vec4)
2D, 3D, and 4D vector types with operators, fields, methods, and memory access functions.

vec2 - 2D Vector
Constructor
Signature: vec2(x, y)

Description: Constructs a 2D vector with the specified components.

Parameters:

x (number): The x-component.

y (number): The y-component.

Returns:

vec2: A new 2D vector object.

Example:

Copy
-- Create a 2D vector
local v = vec2(10, 20)
engine.log("Vector: (" .. v.x .. ", " .. v.y .. ")", 255, 255, 255, 255)
Operators
The following operators are supported for vec2:

Addition: vec2 + vec2 - Adds two vectors component-wise.

Subtraction: vec2 - vec2 - Subtracts two vectors component-wise.

Multiplication: vec2 * scalar - Multiplies each component by a scalar.

Division: vec2 / scalar - Divides each component by a scalar.

Negation: -vec2 - Returns the negated vector.

Length: #vec2 - Returns the length (magnitude) of the vector.

Equality: vec2 == vec2 - Compares two vectors for equality.

Example:

Copy
local v1 = vec2(10, 20)
local v2 = vec2(5, 8)

-- Vector operations
local sum = v1 + v2            -- (15, 28)
local difference = v1 - v2      -- (5, 12)
local scaled = v1 * 2           -- (20, 40)
local divided = v1 / 2          -- (5, 10)
local negated = -v1             -- (-10, -20)
local length = #v1              -- sqrt(10^2 + 20^2) = ~22.36
local equal = (v1 == vec2(10, 20)) -- true

engine.log("Sum: (" .. sum.x .. ", " .. sum.y .. ")", 255, 255, 255, 255)
engine.log("Difference: (" .. difference.x .. ", " .. difference.y .. ")", 255, 255, 255, 255)
engine.log("Scaled: (" .. scaled.x .. ", " .. scaled.y .. ")", 255, 255, 255, 255)
engine.log("Divided: (" .. divided.x .. ", " .. divided.y .. ")", 255, 255, 255, 255)
engine.log("Negated: (" .. negated.x .. ", " .. negated.y .. ")", 255, 255, 255, 255)
engine.log("Length: " .. length, 255, 255, 255, 255)
engine.log("Equal: " .. tostring(equal), 255, 255, 255, 255)
Fields
vec2.x - The x-component of the vector.

vec2.y - The y-component of the vector.

Methods
vec2:length
Signature: vec2:length()

Description: Returns the length (magnitude) of the vector.

Parameters: None

Returns:

number: The vector's length.

Example:

Copy
local v = vec2(3, 4)
local length = v:length()  -- 5
engine.log("Vector: (" .. v.x .. ", " .. v.y .. ")", 255, 255, 255, 255)
engine.log("Length: " .. length, 255, 255, 255, 255)
vec2:length_squared
Signature: vec2:length_squared()

Description: Returns the squared length of the vector (more efficient than length() when comparing distances).

Parameters: None

Returns:

number: The squared length of the vector.

Example:

Copy
local v = vec2(3, 4)
local length_sq = v:length_squared()  -- 25
engine.log("Vector: (" .. v.x .. ", " .. v.y .. ")", 255, 255, 255, 255)
engine.log("Length squared: " .. length_sq, 255, 255, 255, 255)
vec2:normalize
Signature: vec2:normalize()

Description: Returns a normalized copy of the vector (unit vector with the same direction but length 1).

Parameters: None

Returns:

vec2: A normalized vector.

Example:

Copy
local v = vec2(3, 4)
local normalized = v:normalize()
engine.log("Vector: (" .. v.x .. ", " .. v.y .. ")", 255, 255, 255, 255)
engine.log("Normalized: (" .. normalized.x .. ", " .. normalized.y .. ")", 255, 255, 255, 255)
engine.log("Normalized length: " .. normalized:length(), 255, 255, 255, 255)  -- Should be close to 1
vec2:dot
Signature: vec2:dot(v)

Description: Returns the dot product with another vector.

Parameters:

v (vec2): The vector to compute the dot product with.

Returns:

number: The dot product.

Example:

Copy
local v1 = vec2(2, 3)
local v2 = vec2(4, 5)
local dot_product = v1:dot(v2)  -- 2*4 + 3*5 = 8 + 15 = 23
engine.log("Dot product: " .. dot_product, 255, 255, 255, 255)
vec2:distance
Signature: vec2:distance(v)

Description: Returns the distance to another vector.

Parameters:

v (vec2): The vector to compute the distance to.

Returns:

number: The distance between the vectors.

Example:

Copy
local v1 = vec2(1, 1)
local v2 = vec2(4, 5)
local distance = v1:distance(v2)
engine.log("Distance: " .. distance, 255, 255, 255, 255)
vec2:clone
Signature: vec2:clone()

Description: Creates a copy of the vector.

Parameters: None

Returns:

vec2: A new vector with the same components.

Example:

Copy
local original = vec2(10, 20)
local copy = original:clone()
copy.x = 30
engine.log("Original: (" .. original.x .. ", " .. original.y .. ")", 255, 255, 255, 255)
engine.log("Copy: (" .. copy.x .. ", " .. copy.y .. ")", 255, 255, 255, 255)
vec2:perpendicular
Signature: vec2:perpendicular()

Description: Returns a vector perpendicular to this one.

Parameters: None

Returns:

vec2: A perpendicular vector.

Example:

Copy
local v = vec2(3, 4)
local perp = v:perpendicular()
engine.log("Vector: (" .. v.x .. ", " .. v.y .. ")", 255, 255, 255, 255)
engine.log("Perpendicular: (" .. perp.x .. ", " .. perp.y .. ")", 255, 255, 255, 255)
engine.log("Dot product (should be 0): " .. v:dot(perp), 255, 255, 255, 255)
vec2:angle
Signature: vec2:angle()

Description: Returns the angle in radians from the X-axis.

Parameters: None

Returns:

number: The angle in radians.

Example:

Copy
local v = vec2(1, 1)  -- 45 degrees
local angle = v:angle()
engine.log("Angle in radians: " .. angle, 255, 255, 255, 255)
engine.log("Angle in degrees: " .. (angle * 180 / math.pi), 255, 255, 255, 255)
vec2:rotate
Signature: vec2:rotate(radians)

Description: Rotates the vector by an angle in radians.

Parameters:

radians (number): The angle to rotate by in radians.

Returns:

vec2: The rotated vector.

Example:

Copy
local v = vec2(1, 0)
local rotated = v:rotate(math.pi / 2)  -- 90 degrees
engine.log("Original: (" .. v.x .. ", " .. v.y .. ")", 255, 255, 255, 255)
engine.log("Rotated 90 degrees: (" .. rotated.x .. ", " .. rotated.y .. ")", 255, 255, 255, 255)
vec2:lerp
Signature: vec2:lerp(v, t)

Description: Linearly interpolates toward another vector by a factor t.

Parameters:

v (vec2): The target vector.

t (number): The interpolation factor (0-1).

Returns:

vec2: The interpolated vector.

Example:

Copy
local v1 = vec2(0, 0)
local v2 = vec2(10, 20)
local half = v1:lerp(v2, 0.5)  -- Halfway between v1 and v2
engine.log("From: (" .. v1.x .. ", " .. v1.y .. ")", 255, 255, 255, 255)
engine.log("To: (" .. v2.x .. ", " .. v2.y .. ")", 255, 255, 255, 255)
engine.log("Halfway: (" .. half.x .. ", " .. half.y .. ")", 255, 255, 255, 255)
Additional vec2 Methods
vec2:project_onto(v) - Projects this vector onto vector v.

vec2:clamp_length(min, max) - Clamps the vector's length between min and max.

vec2:reflect(normal) - Reflects the vector off the given normal.

Memory Access
vec2.read_float(address) - Reads a vec2 from memory (float precision).

vec2.read_double(address) - Reads a vec2 from memory (double precision).

vec2.write_float(address, v) - Writes a vec2 to memory (float precision).

vec2.write_double(address, v) - Writes a vec2 to memory (double precision).

vec3 - 3D Vector
Constructor
Signature: vec3(x, y, z)

Description: Constructs a 3D vector with the specified components.

Parameters:

x (number): The x-component.

y (number): The y-component.

z (number): The z-component.

Returns:

vec3: A new 3D vector object.

Example:

Copy
-- Create a 3D vector
local v = vec3(10, 20, 30)
engine.log("Vector: (" .. v.x .. ", " .. v.y .. ", " .. v.z .. ")", 255, 255, 255, 255)
Operators
The vec3 supports the same operators as vec2, including:

Addition: vec3 + vec3

Subtraction: vec3 - vec3

Multiplication: vec3 * scalar

Division: vec3 / scalar

Negation: -vec3

Length: #vec3

Equality: vec3 == vec3

Fields
vec3.x - The x-component of the vector.

vec3.y - The y-component of the vector.

vec3.z - The z-component of the vector.

Methods
Length & Normalization
vec3:length() - Returns the 3D vector's length.

vec3:length_2d() - Returns the 2D (XY) length, ignoring the Z component.

vec3:length_2d_squared() - Returns the squared 2D length.

vec3:normalize() - Returns a normalized version of the vector.

vec3:clamp_length(min, max) - Clamps vector length between min and max.

Math & Direction
vec3:dot(v) - Dot product with another vector.

vec3:cross(v) - Cross product with another vector.

vec3:distance(v) - Distance to another vector.

vec3:angle_between(v) - Angle in radians between vectors.

vec3:reflect(normal) - Reflects the vector off a surface normal.

vec3:project_onto(v) - Projects this vector onto vector v.

vec3:rotate_axis(angle, axis) - Rotates the vector around an axis.

Utility
vec3:clone() - Returns a copy of the vector.

vec3:lerp(v, t) - Linear interpolation with vector v.

vec3:slerp(v, t) - Spherical linear interpolation.

Angle & Orientation
vec3:to_forward() - Converts angles to a forward direction vector.

vec3:to_right() - Converts angles to a right vector.

vec3:to_up() - Converts angles to an up vector.

vec3:to_qangle() - Returns pitch, yaw, roll as a vector.

vec3:normalize_angles() - Normalizes pitch/yaw.

vec3:clamp_angles() - Clamps pitch/yaw; sets roll to 0.

vec3.normalize_angle(angle) - Normalizes a single angle value.

vec3.from_qangle(pitch, yaw) - Converts pitch/yaw into a direction vector.

Example:

Copy
-- Create 3D vectors
local v1 = vec3(1, 0, 0)  -- Unit vector along X axis
local v2 = vec3(0, 1, 0)  -- Unit vector along Y axis

-- Get cross product (should be unit vector along Z axis)
local cross = v1:cross(v2)
engine.log("v1 cross v2: (" .. cross.x .. ", " .. cross.y .. ", " .. cross.z .. ")", 255, 255, 255, 255)

-- Get dot product (should be 0 for perpendicular vectors)
local dot = v1:dot(v2)
engine.log("v1 dot v2: " .. dot, 255, 255, 255, 255)

-- Get angle between vectors (should be 90 degrees = /2)
local angle = v1:angle_between(v2)
engine.log("Angle between v1 and v2 (radians): " .. angle, 255, 255, 255, 255)
engine.log("Angle between v1 and v2 (degrees): " .. (angle * 180 / math.pi), 255, 255, 255, 255)
Memory Access
vec3.read_float(address) - Reads a vec3 from memory (float).

vec3.read_double(address) - Reads a vec3 from memory (double).

vec3.write_float(address, v) - Writes a vec3 to memory (float).

vec3.write_double(address, v) - Writes a vec3 to memory (double).

vec4 - 4D Vector
Constructor
Signature: vec4(x, y, z, w)

Description: Constructs a 4D vector with the specified components.

Parameters:

x (number): The x-component.

y (number): The y-component.

z (number): The z-component.

w (number): The w-component.

Returns:

vec4: A new 4D vector object.

Example:

Copy
-- Create a 4D vector (commonly used for RGBA colors or quaternions)
local v = vec4(255, 0, 0, 255)  -- Red color with full alpha
engine.log("Vector: (" .. v.x .. ", " .. v.y .. ", " .. v.z .. ", " .. v.w .. ")", 255, 255, 255, 255)
Operators
The vec4 supports the same operators as vec2 and vec3, including:

Addition: vec4 + vec4

Subtraction: vec4 - vec4

Multiplication: vec4 * scalar

Division: vec4 / scalar

Negation: -vec4

Length: #vec4

Equality: vec4 == vec4

Fields
vec4.x - The x-component of the vector.

vec4.y - The y-component of the vector.

vec4.z - The z-component of the vector.

vec4.w - The w-component of the vector.

Methods
Length & Normalization
vec4:length() - Returns the vector's magnitude.

vec4:normalize() - Returns a normalized version.

Math & Utility
vec4:dot(v) - Computes the dot product with another vec4.

vec4:clone() - Returns a copy of the vector.

vec4:lerp(v, t) - Linearly interpolates toward v by factor t.

vec4:clamp_length(min, max) - Clamps the vector length.

vec4:project_onto(v) - Projects this vector onto another.

vec4:reflect(normal) - Reflects the vector off a surface normal.

Example:

Copy
-- Create two 4D vectors
local color1 = vec4(255, 0, 0, 255)  -- Red
local color2 = vec4(0, 0, 255, 255)  -- Blue

-- Interpolate between them (purple with 50% blend)
local purple = color1:lerp(color2, 0.5)
engine.log("Interpolated color: (" .. purple.x .. ", " .. purple.y .. ", " .. purple.z .. ", " .. purple.w .. ")", 
           purple.x, purple.y, purple.z, purple.w)
Memory Access
vec4.read_float(address) - Reads a vec4 from memory (float precision).

vec4.read_double(address) - Reads a vec4 from memory (double precision).

vec4.write_float(address, v) - Writes a vec4 to memory (float precision).

vec4.write_double(address, v) - Writes a vec4 to memory (double precision).

Matrix
44 transformation matrices for translation, rotation, scaling, and projection.

mat4 - 44 Matrix API
Constructor
Signature: mat4()

Description: Creates a new 44 identity matrix.

Parameters: None

Returns:

mat4: A new 44 identity matrix.

Example:

Copy
-- Create a new identity matrix
local matrix = mat4()
engine.log("Created a new 44 identity matrix", 255, 255, 255, 255)
Operators
The following operators are supported for mat4:

Multiplication: mat4 * mat4 - Multiplies two matrices (matrix composition).

Transformation: mat4 * vec4 - Transforms a vec4 using the matrix.

Example:

Copy
-- Create an identity matrix
local m1 = mat4()

-- Create a translation matrix
local translation = mat4()
translation:translate(vec3(10, 20, 30))

-- Multiply matrices
local result = m1 * translation

-- Transform a point
local point = vec4(1, 2, 3, 1)
local transformed = result * point
engine.log("Original point: (" .. point.x .. ", " .. point.y .. ", " .. point.z .. ")", 255, 255, 255, 255)
engine.log("Transformed point: (" .. transformed.x .. ", " .. transformed.y .. ", " .. transformed.z .. ")", 255, 255, 255, 255)
Access & Structure Methods
mat4:get
Signature: mat4:get(row, col)

Description: Gets the value at the specified row and column.

Parameters:

row (number): The row index (1-4).

col (number): The column index (1-4).

Returns:

number: The value at the specified position.

Example:

Copy
local m = mat4()
local value = m:get(1, 1)  -- Should be 1 for identity matrix
engine.log("Value at (1,1): " .. value, 255, 255, 255, 255)
mat4:set
Signature: mat4:set(row, col, value)

Description: Sets the value at the specified row and column.

Parameters:

row (number): The row index (1-4).

col (number): The column index (1-4).

value (number): The value to set.

Returns: None

Example:

Copy
local m = mat4()
m:set(1, 2, 5)  -- Set element at row 1, column 2 to 5
engine.log("Modified matrix element (1,2) to 5", 255, 255, 255, 255)
mat4:row
Signature: mat4:row(index)

Description: Returns a row of the matrix as a vec4.

Parameters:

index (number): The row index (1-4).

Returns:

vec4: The row vector.

Example:

Copy
local m = mat4()
local first_row = m:row(1)  -- Should be (1,0,0,0) for identity matrix
engine.log("First row: (" .. first_row.x .. ", " .. first_row.y .. ", " .. first_row.z .. ", " .. first_row.w .. ")", 255, 255, 255, 255)
mat4:column
Signature: mat4:column(index)

Description: Returns a column of the matrix as a vec4.

Parameters:

index (number): The column index (1-4).

Returns:

vec4: The column vector.

Example:

Copy
local m = mat4()
local first_column = m:column(1)  -- Should be (1,0,0,0) for identity matrix
engine.log("First column: (" .. first_column.x .. ", " .. first_column.y .. ", " .. first_column.z .. ", " .. first_column.w .. ")", 255, 255, 255, 255)
mat4:clone
Signature: mat4:clone()

Description: Creates a copy of the matrix.

Parameters: None

Returns:

mat4: A new matrix with the same values.

Example:

Copy
local original = mat4()
original:set(1, 1, 2)  -- Modify the original matrix

local copy = original:clone()
engine.log("Original (1,1): " .. original:get(1, 1), 255, 255, 255, 255)
engine.log("Copy (1,1): " .. copy:get(1, 1), 255, 255, 255, 255)
mat4:to_table
Signature: mat4:to_table()

Description: Converts the matrix to a nested Lua table.

Parameters: None

Returns:

table: A 44 nested table representing the matrix.

Example:

Copy
local m = mat4()
local table_form = m:to_table()
engine.log("Matrix converted to table", 255, 255, 255, 255)
mat4.from_table
Signature: mat4.from_table(table)

Description: Constructs a matrix from a nested Lua table.

Parameters:

table (table): A 44 nested table representing the matrix.

Returns:

mat4: A new matrix with values from the table.

Example:

Copy
local table_data = {
    {1, 0, 0, 0},
    {0, 1, 0, 0},
    {0, 0, 1, 0},
    {0, 0, 0, 1}
}
local m = mat4.from_table(table_data)
engine.log("Matrix created from table", 255, 255, 255, 255)
Transformation Methods
mat4:transpose
Signature: mat4:transpose()

Description: Returns the transposed matrix (rows become columns).

Parameters: None

Returns:

mat4: The transposed matrix.

Example:

Copy
local m = mat4()
m:set(1, 2, 5)  -- Set element at row 1, column 2 to 5
local transposed = m:transpose()
engine.log("Original (1,2): " .. m:get(1, 2), 255, 255, 255, 255)
engine.log("Transposed (2,1): " .. transposed:get(2, 1), 255, 255, 255, 255)
mat4:inverse
Signature: mat4:inverse()

Description: Returns the inverse of the matrix.

Parameters: None

Returns:

mat4: The inverse matrix, or nil if the matrix is singular (non-invertible).

Example:

Copy
local m = mat4()
m:translate(vec3(10, 20, 30))  -- Create a translation matrix
local inv = m:inverse()

-- Test if m * inv = identity
local result = m * inv
engine.log("Result (1,1): " .. result:get(1, 1), 255, 255, 255, 255)  -- Should be close to 1
engine.log("Result (4,1): " .. result:get(4, 1), 255, 255, 255, 255)  -- Should be close to 0
mat4:determinant
Signature: mat4:determinant()

Description: Returns the determinant of the matrix.

Parameters: None

Returns:

number: The matrix determinant.

Example:

Copy
local m = mat4()
local det = m:determinant()  -- Should be 1 for identity matrix
engine.log("Determinant: " .. det, 255, 255, 255, 255)
mat4:scale
Signature: mat4:scale(vec3)

Description: Scales the matrix by a vec3.

Parameters:

vec3 (vec3): The scale factors for each axis.

Returns:

mat4: The scaled matrix.

Example:

Copy
local m = mat4()
m:scale(vec3(2, 3, 4))  -- Scale by 2 in X, 3 in Y, 4 in Z
engine.log("Matrix scaled", 255, 255, 255, 255)

-- Test the scaling
local point = vec4(1, 1, 1, 1)
local scaled = m * point
engine.log("Scaled point: (" .. scaled.x .. ", " .. scaled.y .. ", " .. scaled.z .. ")", 255, 255, 255, 255)
mat4:translate
Signature: mat4:translate(vec3)

Description: Applies translation to the matrix.

Parameters:

vec3 (vec3): The translation vector.

Returns:

mat4: The translated matrix.

Example:

Copy
local m = mat4()
m:translate(vec3(10, 20, 30))  -- Translate by (10, 20, 30)
engine.log("Matrix translated", 255, 255, 255, 255)

-- Test the translation
local point = vec4(0, 0, 0, 1)
local translated = m * point
engine.log("Translated point: (" .. translated.x .. ", " .. translated.y .. ", " .. translated.z .. ")", 255, 255, 255, 255)
mat4:rotate
Signature: mat4:rotate(angle, axis)

Description: Rotates the matrix around an axis by an angle in radians.

Parameters:

angle (number): The rotation angle in radians.

axis (vec3): The rotation axis (should be normalized).

Returns:

mat4: The rotated matrix.

Example:

Copy
local m = mat4()
m:rotate(math.pi / 2, vec3(0, 0, 1))  -- Rotate 90 degrees around Z axis
engine.log("Matrix rotated", 255, 255, 255, 255)

-- Test the rotation
local point = vec4(1, 0, 0, 1)
local rotated = m * point
engine.log("Rotated point: (" .. rotated.x .. ", " .. rotated.y .. ", " .. rotated.z .. ")", 255, 255, 255, 255)
mat4:apply_to_vec3
Signature: mat4:apply_to_vec3(vec3)

Description: Applies the matrix transformation to a vec3.

Parameters:

vec3 (vec3): The vector to transform.

Returns:

vec3: The transformed vector.

Example:

Copy
local m = mat4()
m:translate(vec3(10, 20, 30))

local point = vec3(1, 2, 3)
local transformed = m:apply_to_vec3(point)
engine.log("Original: (" .. point.x .. ", " .. point.y .. ", " .. point.z .. ")", 255, 255, 255, 255)
engine.log("Transformed: (" .. transformed.x .. ", " .. transformed.y .. ", " .. transformed.z .. ")", 255, 255, 255, 255)
Decomposition & Comparison
mat4:decompose
Signature: mat4:decompose()

Description: Returns position, rotation, and scale components of the matrix.

Parameters: None

Returns:

position (vec3): The translation component.

rotation (vec4): The rotation as a quaternion.

scale (vec3): The scale component.

Example:

Copy
local m = mat4()
m:translate(vec3(10, 20, 30))
m:scale(vec3(2, 2, 2))

local position, rotation, scale = m:decompose()
engine.log("Position: (" .. position.x .. ", " .. position.y .. ", " .. position.z .. ")", 255, 255, 255, 255)
engine.log("Scale: (" .. scale.x .. ", " .. scale.y .. ", " .. scale.z .. ")", 255, 255, 255, 255)
mat4:equals
Signature: mat4:equals(other, tolerance?)

Description: Compares with another matrix for equality.

Parameters:

other (mat4): The matrix to compare with.

tolerance (number, optional): The comparison tolerance. Defaults to a small epsilon value.

Returns:

boolean: true if the matrices are equal within the tolerance, false otherwise.

Example:

Copy
local m1 = mat4()
local m2 = mat4()
local m3 = mat4():translate(vec3(0.0001, 0, 0))

engine.log("m1 equals m2: " .. tostring(m1:equals(m2)), 255, 255, 255, 255)  -- true
engine.log("m1 equals m3: " .. tostring(m1:equals(m3)), 255, 255, 255, 255)  -- false
engine.log("m1 equals m3 with tolerance: " .. tostring(m1:equals(m3, 0.001)), 255, 255, 255, 255)  -- true
mat4:is_identity
Signature: mat4:is_identity()

Description: Returns true if the matrix is an identity matrix.

Parameters: None

Returns:

boolean: true if the matrix is identity, false otherwise.

Example:

Copy
local m1 = mat4()
local m2 = mat4():translate(vec3(1, 0, 0))

engine.log("m1 is identity: " .. tostring(m1:is_identity()), 255, 255, 255, 255)  -- true
engine.log("m2 is identity: " .. tostring(m2:is_identity()), 255, 255, 255, 255)  -- false
Memory Access
mat4.read
Signature: mat4.read(address)

Description: Reads a mat4 from memory.

Parameters:

address (number): The memory address to read from.

Returns:

mat4: The matrix read from memory.

Example:

Copy
-- This example assumes we have valid memory operations
local buffer = m.alloc(16 * 4)  -- Allocate space for 16 floats
-- ... write matrix data to buffer ...
local matrix = mat4.read(buffer)
engine.log("Matrix read from memory", 255, 255, 255, 255)
m.free(buffer)
Special Matrix Constructors
mat4.perspective
Signature: mat4.perspective(fov_y, aspect, near, far)

Description: Creates a perspective projection matrix.

Parameters:

fov_y (number): The field of view angle in the Y direction, in radians.

aspect (number): The aspect ratio (width/height).

near (number): The distance to the near clipping plane.

far (number): The distance to the far clipping plane.

Returns:

mat4: A perspective projection matrix.

Example:

Copy
-- Create a perspective projection matrix
local fov = 60 * (math.pi / 180)  -- 60 degrees in radians
local aspect = 1280 / 720          -- 16:9 aspect ratio
local near = 0.1
local far = 1000.0
local proj = mat4.perspective(fov, aspect, near, far)
engine.log("Created perspective projection matrix", 255, 255, 255, 255)
mat4.orthographic
Signature: mat4.orthographic(left, right, bottom, top, near, far)

Description: Creates an orthographic projection matrix.

Parameters:

left (number): The left coordinate of the viewing volume.

right (number): The right coordinate of the viewing volume.

bottom (number): The bottom coordinate of the viewing volume.

top (number): The top coordinate of the viewing volume.

near (number): The near depth clipping plane.

far (number): The far depth clipping plane.

Returns:

mat4: An orthographic projection matrix.

Example:

Copy
-- Create an orthographic projection matrix
local left = -5
local right = 5
local bottom = -5
local top = 5
local near = 0.1
local far = 100.0
local ortho = mat4.orthographic(left, right, bottom, top, near, far)
engine.log("Created orthographic projection matrix", 255, 255, 255, 255)
mat4.trs
Signature: mat4.trs(position, rotation_quat, scale)

Description: Creates a matrix from translation, rotation (quaternion), and scale.

Parameters:

position (vec3): The translation vector.

rotation_quat (vec4): The rotation as a quaternion.

scale (vec3): The scale vector.

Returns:

mat4: A transformation matrix.

Example:

Copy
-- Create a transformation matrix with translation, rotation and scale
local position = vec3(10, 0, 0)
local rotation = vec4(0, 0, 0, 1)  -- Identity quaternion
local scale = vec3(2, 1, 1)
local matrix = mat4.trs(position, rotation, scale)
engine.log("Created TRS matrix", 255, 255, 255, 255)
mat4.look_at
Signature: mat4.look_at(eye, target, up)

Description: Creates a view matrix looking at a target from a position.

Parameters:

eye (vec3): The camera position.

target (vec3): The point to look at.

up (vec3): The up vector.

Returns:

mat4: A view matrix.

Example:

Copy
-- Create a view matrix for a camera
local eye = vec3(0, 0, 5)     -- Camera position
local target = vec3(0, 0, 0)  -- Looking at the origin
local up = vec3(0, 1, 0)      -- Y-axis is up
local view = mat4.look_at(eye, target, up)
engine.log("Created view matrix", 255, 255, 255, 255)
Matrix Transformations Workflow
Creating and Composing Transformations
Example:

Copy
-- Create individual transformation matrices
local translate = mat4()
translate:translate(vec3(10, 0, 0))  -- Translate 10 units along X

local rotate = mat4()
rotate:rotate(math.pi/4, vec3(0, 0, 1))  -- Rotate 45 degrees around Z axis

local scale = mat4()
scale:scale(vec3(2, 2, 2))  -- Scale by 2 in all directions

-- Combine transformations (applied right-to-left: scale, then rotate, then translate)
local transform = translate * rotate * scale

-- Apply to a point
local point = vec4(1, 0, 0, 1)
local transformed = transform * point

engine.log("Original point: (" .. point.x .. ", " .. point.y .. ", " .. point.z .. ")", 255, 255, 255, 255)
engine.log("Transformed point: (" .. transformed.x .. ", " .. transformed.y .. ", " .. transformed.z .. ")", 255, 255, 255, 255)
Creating a Camera Matrix
Example:

Copy
-- Set up camera parameters
local eye = vec3(0, 0, 5)     -- Camera position
local target = vec3(0, 0, 0)  -- Looking at the origin
local up = vec3(0, 1, 0)      -- Y-axis is up

-- Create view matrix
local view = mat4.look_at(eye, target, up)

-- Create projection matrix (perspective)
local fov = 60 * (math.pi / 180)  -- 60 degrees in radians
local aspect = 16 / 9              -- 16:9 aspect ratio
local near = 0.1
local far = 100.0
local projection = mat4.perspective(fov, aspect, near, far)

-- Combine view and projection matrices
local view_projection = projection * view

-- Apply to a world-space point
local world_point = vec4(10, 0, 0, 1)
local clip_space = view_projection * world_point

engine.log("World point: (" .. world_point.x .. ", " .. world_point.y .. ", " .. world_point.z .. ")", 255, 255, 255, 255)
engine.log("Clip space: (" .. clip_space.x .. ", " .. clip_space.y .. ", " .. clip_space.z .. ", " .. clip_space.w .. ")", 255, 255, 255, 255)
Windows
System, audio, and window functions for interacting with the Windows platform.

System Functions
winapi.get_tickcount64
Signature: winapi.get_tickcount64()

Description: Returns the system uptime in milliseconds as a 64-bit integer.

Parameters: None

Returns:

number: The number of milliseconds that have elapsed since the system was started.

Example:

Copy
local uptime_ms = winapi.get_tickcount64()
local uptime_seconds = uptime_ms / 1000
local uptime_minutes = uptime_seconds / 60
local uptime_hours = uptime_minutes / 60
local uptime_days = uptime_hours / 24

engine.log("System uptime: " .. uptime_ms .. " ms", 255, 255, 255, 255)
engine.log("System uptime: " .. math.floor(uptime_days) .. " days, " .. 
           math.floor(uptime_hours % 24) .. " hours, " .. 
           math.floor(uptime_minutes % 60) .. " minutes", 255, 255, 255, 255)
Audio Playback
winapi.play_sound
Signature: winapi.play_sound(file_name)

Description: Plays a sound file (supports .wav and .mp3). The file can be a full path or a file located in the My Games directory.

Parameters:

file_name (string): Path to the sound file to play.

Returns:

boolean: true if the sound was played successfully, false otherwise.

Example:

Copy
-- Play a sound file
local success = winapi.play_sound("sounds/notification.wav")
if success then
    engine.log("Sound played successfully", 0, 255, 0, 255)
else
    engine.log("Failed to play sound", 255, 0, 0, 255)
end

-- Play a sound when a specific event occurs
function on_achievement_unlocked()
    winapi.play_sound("sounds/achievement.wav")
    engine.log("Achievement unlocked!", 255, 255, 0, 255)
end
Window Handling
winapi.get_hwnd
Signature: winapi.get_hwnd(class_name, window_name)

Description: Returns a window handle (HWND) as an integer. Both parameters can be nil to perform a broad match.

Parameters:

class_name (string, optional): The window class name to search for.

window_name (string, optional): The window title to search for.

Returns:

number: The window handle (HWND) if found, or nil if not found.

Example:

Copy
-- Find a window by its title
local notepad_hwnd = winapi.get_hwnd(nil, "Untitled - Notepad")
if notepad_hwnd then
    engine.log("Found Notepad window: " .. notepad_hwnd, 0, 255, 0, 255)
else
    engine.log("Notepad window not found", 255, 0, 0, 255)
end

-- Find a window by both class and title
local calculator_hwnd = winapi.get_hwnd("CalcFrame", "Calculator")
if calculator_hwnd then
    engine.log("Found Calculator window: " .. calculator_hwnd, 0, 255, 0, 255)
else
    engine.log("Calculator window not found", 255, 0, 0, 255)
end
Message Posting
winapi.post_message
Signature: winapi.post_message(hwnd, msg, wparam, lparam)

Description: Sends a Windows message to the given window handle. All arguments must be integers.

Parameters:

hwnd (number): The window handle to send the message to.

msg (number): The message ID to send.

wparam (number): The WPARAM value (interpretation depends on the message).

lparam (number): The LPARAM value (interpretation depends on the message).

Returns:

boolean: true if the message was successfully posted, false otherwise.

Example:

Copy
-- Find a window and send a message to it
local hwnd = winapi.get_hwnd(nil, "Untitled - Notepad")
if hwnd then
    -- Windows message constants
    local WM_CLOSE = 0x0010
    
    -- Send a message to close the window
    local success = winapi.post_message(hwnd, WM_CLOSE, 0, 0)
    if success then
        engine.log("Close message sent successfully", 0, 255, 0, 255)
    else
        engine.log("Failed to send close message", 255, 0, 0, 255)
    end
else
    engine.log("Target window not found", 255, 0, 0, 255)
end
Windows API Usage Examples
System Uptime Monitor
Copy
-- Function to format uptime in a readable way
function format_uptime(milliseconds)
    local seconds = milliseconds / 1000
    local minutes = seconds / 60
    local hours = minutes / 60
    local days = hours / 24
    
    return string.format("%d days, %02d:%02d:%02d",
                         math.floor(days),
                         math.floor(hours % 24),
                         math.floor(minutes % 60),
                         math.floor(seconds % 60))
end

-- Log uptime when script starts
local start_uptime = winapi.get_tickcount64()
engine.log("System uptime: " .. format_uptime(start_uptime), 255, 255, 255, 255)

-- Register a function to periodically check uptime
engine.register_on_engine_tick(function()
    -- Check uptime every 60 seconds
    local current_uptime = winapi.get_tickcount64()
    local elapsed = current_uptime - start_uptime
    
    if elapsed > 60000 then
        engine.log("Updated system uptime: " .. format_uptime(current_uptime), 255, 255, 255, 255)
        start_uptime = current_uptime
    end
end)
Sound Effect Player
Copy
-- Create a sound effect manager
local SoundManager = {
    sounds = {
        click = "sounds/click.wav",
        success = "sounds/success.wav",
        error = "sounds/error.wav",
        notification = "sounds/notification.wav"
    }
}

function SoundManager:play(sound_name)
    if not self.sounds[sound_name] then
        engine.log("Sound not found: " .. sound_name, 255, 0, 0, 255)
        return false
    end
    
    local success = winapi.play_sound(self.sounds[sound_name])
    if not success then
        engine.log("Failed to play sound: " .. sound_name, 255, 0, 0, 255)
    end
    
    return success
end

-- Usage examples
function on_button_click()
    SoundManager:play("click")
    -- Handle button click logic
end

function on_operation_success()
    SoundManager:play("success")
    engine.log("Operation completed successfully", 0, 255, 0, 255)
end

function on_operation_error()
    SoundManager:play("error")
    engine.log("Operation failed", 255, 0, 0, 255)
end
Window Management
Copy
-- Window manager for tracking and interacting with specific applications
local WindowManager = {
    target_windows = {}
}

-- Find and store a window handle by window title
function WindowManager:find_window(identifier, window_title)
    local hwnd = winapi.get_hwnd(nil, window_title)
    
    if hwnd then
        self.target_windows[identifier] = {
            hwnd = hwnd,
            title = window_title
        }
        engine.log("Found window '" .. window_title .. "': " .. hwnd, 0, 255, 0, 255)
        return true
    else
        engine.log("Window not found: " .. window_title, 255, 0, 0, 255)
        return false
    end
end

-- Close a tracked window
function WindowManager:close_window(identifier)
    local window = self.target_windows[identifier]
    if not window then
        engine.log("Window identifier not found: " .. identifier, 255, 0, 0, 255)
        return false
    end
    
    -- Windows message constants
    local WM_CLOSE = 0x0010
    
    local success = winapi.post_message(window.hwnd, WM_CLOSE, 0, 0)
    if success then
        engine.log("Close message sent to '" .. window.title .. "'", 0, 255, 0, 255)
        self.target_windows[identifier] = nil
    else
        engine.log("Failed to send close message to '" .. window.title .. "'", 255, 0, 0, 255)
    end
    
    return success
end

-- Check if a tracked window still exists
function WindowManager:window_exists(identifier)
    local window = self.target_windows[identifier]
    if not window then
        return false
    end
    
    -- Try to find the window again to see if it still exists
    local hwnd = winapi.get_hwnd(nil, window.title)
    return hwnd ~= nil
end

-- Usage example
WindowManager:find_window("notepad", "Untitled - Notepad")
WindowManager:find_window("calculator", "Calculator")

-- Later, when we need to close the windows
if WindowManager:window_exists("notepad") then
    WindowManager:close_window("notepad")
end
Extended API
Marvel Rivals
Functions for interacting with player data, world coordinates, bones, and game objects.

marvel_rivals.get_local_player
Signature: marvel_rivals.get_local_player()

Description: Returns information about the local player, including pointers to various game objects and bone IDs.

Parameters: None

Returns:

table: A table containing the following fields:

player_controller (integer): Pointer to the player controller

skeletal_mesh (integer): Pointer to the skeletal mesh

root_component (integer): Pointer to the root component

child_actor_component (integer): Pointer to the child actor component

child_actor (integer): Pointer to the child actor

bone_array (integer): Pointer to the bone array

health_component (integer): Pointer to the health component

player_state (integer): Pointer to the player state

pawn (integer): Pointer to the pawn

hero_name (string): Name of the hero

bone_id_* (integer): Various bone IDs (e.g., bone_id_head, bone_id_chest, etc.)

Returns nil if local player data is not available.

Example:

Copy
local local_player = marvel_rivals.get_local_player()

if not local_player then
    engine.log("Local player not available", 255, 0, 0, 255)
    return
end

engine.log("Hero: " .. local_player.hero_name, 0, 255, 0, 255)

-- Access bone IDs
engine.log("Head bone ID: " .. tostring(local_player.bone_id_head), 255, 255, 255, 255)
engine.log("Chest bone ID: " .. tostring(local_player.bone_id_chest), 255, 255, 255, 255)
marvel_rivals.get_player_list
Signature: marvel_rivals.get_player_list()

Description: Returns a table of all players in the game, with the same data structure as get_local_player for each player.

Parameters: None

Returns:

table: A table of player data, where each entry contains:

skeletal_mesh (integer): Pointer to the skeletal mesh

root_component (integer): Pointer to the root component

child_actor_component (integer): Pointer to the child actor component

child_actor (integer): Pointer to the child actor

bone_array (integer): Pointer to the bone array

health_component (integer): Pointer to the health component

player_state (integer): Pointer to the player state

pawn (integer): Pointer to the pawn

hero_name (string): Name of the hero

bone_id_* (integer): Various bone IDs

Returns nil if player list is not available.

Example:

Copy
local players = marvel_rivals.get_player_list()

if not players then
    engine.log("Player list unavailable", 255, 0, 0, 255)
    return
end

engine.log("Players found: " .. #players, 0, 255, 0, 255)

for i, player in ipairs(players) do
    engine.log("Player " .. i .. ": " .. player.hero_name, 255, 255, 0, 255)
    
    -- Check if this player has a health component
    if player.health_component ~= 0 then
        -- Process health component
        engine.log("  Has health component", 0, 255, 0, 255)
    end
end
marvel_rivals.get_world
Signature: marvel_rivals.get_world()

Description: Returns the pointer to the UWorld object.

Parameters: None

Returns:

integer: Pointer to the UWorld object.

Example:

Copy
local world_ptr = marvel_rivals.get_world()

if world_ptr == 0 then
    engine.log("UWorld not available", 255, 0, 0, 255)
    return
end

engine.log("UWorld pointer: 0x" .. string.format("%X", world_ptr), 0, 255, 0, 255)
marvel_rivals.get_game_instance
Signature: marvel_rivals.get_game_instance()

Description: Returns the pointer to the UGameInstance object.

Parameters: None

Returns:

integer: Pointer to the UGameInstance object.

Example:

Copy
local game_instance_ptr = marvel_rivals.get_game_instance()

if game_instance_ptr == 0 then
    engine.log("UGameInstance not available", 255, 0, 0, 255)
    return
end

engine.log("UGameInstance pointer: 0x" .. string.format("%X", game_instance_ptr), 0, 255, 0, 255)
marvel_rivals.get_game_state
Signature: marvel_rivals.get_game_state()

Description: Returns the pointer to the AGameStateBase object.

Parameters: None

Returns:

integer: Pointer to the AGameStateBase object.

Example:

Copy
local game_state_ptr = marvel_rivals.get_game_state()

if game_state_ptr == 0 then
    engine.log("AGameStateBase not available", 255, 0, 0, 255)
    return
end

engine.log("AGameStateBase pointer: 0x" .. string.format("%X", game_state_ptr), 0, 255, 0, 255)
marvel_rivals.world_to_screen
Signature: marvel_rivals.world_to_screen(x, y, z)

Description: Converts 3D world coordinates to 2D screen coordinates.

Parameters:

x (number): X coordinate in world space

y (number): Y coordinate in world space

z (number): Z coordinate in world space

Returns:

x (number): X coordinate in screen space

y (number): Y coordinate in screen space

Returns nil if conversion fails.

Example:

Copy
-- Convert world position to screen position
local world_x, world_y, world_z = 100, 200, 300
local screen_x, screen_y = marvel_rivals.world_to_screen(world_x, world_y, world_z)

if screen_x and screen_y then
    engine.log("World (" .. world_x .. ", " .. world_y .. ", " .. world_z .. ") -> Screen (" .. screen_x .. ", " .. screen_y .. ")", 0, 255, 0, 255)
    
    -- Draw a marker at the screen position
    render.draw_circle(screen_x, screen_y, 5, 255, 0, 0, 255, 1, true)
else
    engine.log("Failed to convert world position to screen position", 255, 0, 0, 255)
end
marvel_rivals.get_bone_position
Signature: marvel_rivals.get_bone_position(skeletal_mesh, bone_id)

Description: Returns the world position of the specified bone.

Parameters:

skeletal_mesh (integer): Pointer to the skeletal mesh

bone_id (integer): ID of the bone to get the position of

Returns:

x (number): X coordinate of the bone in world space

y (number): Y coordinate of the bone in world space

z (number): Z coordinate of the bone in world space

Returns nil if conversion fails.

Example:

Copy
local local_player = marvel_rivals.get_local_player()

if not local_player then
    engine.log("Local player not available", 255, 0, 0, 255)
    return
end

-- Get the world position of the player's head
local head_x, head_y, head_z = marvel_rivals.get_bone_position(local_player.skeletal_mesh, local_player.bone_id_head)

if head_x then
    engine.log("Head position: (" .. head_x .. ", " .. head_y .. ", " .. head_z .. ")", 0, 255, 0, 255)
    
    -- Convert to screen coordinates and draw a marker
    local screen_x, screen_y = marvel_rivals.world_to_screen(head_x, head_y, head_z)
    if screen_x and screen_y then
        render.draw_circle(screen_x, screen_y, 5, 255, 0, 0, 255, 1, true)
    end
else
    engine.log("Failed to get head bone position", 255, 0, 0, 255)
end
marvel_rivals.get_class_dump
Signature: marvel_rivals.get_class_dump(pointer)

Description: Returns a table containing the class fields for the specified class pointer in Marvel Rivals. This is useful for reverse engineering or understanding the internal structure of class objects at runtime.

Parameters:

pointer (integer): The memory address of the class you want to dump.

Returns:

table: A table of class fields with the following structure:

Copy
{
    [1] = { name = "PlayerController::AcknowledgedPawn", offset = 0x120 },
    [2] = { name = "Controller::ControlRotation", offset = 0x154 },
    ...
}
Returns nil and logs an error if:

Argument is missing or not an integer

Pointer is null

Dump is empty

Example:

Copy
-- Basic usage
local pointer = 0x1A2B3C4D  -- Replace with actual class pointer (e.g., uworld)
local dump = marvel_rivals.get_class_dump(pointer)

if dump == nil then
    engine.log("Class dump failed.", 255, 0, 0, 255)
    return
end

for i, entry in ipairs(dump) do
    engine.log(string.format("%s = 0x%X", entry.name, entry.offset), 0, 255, 0, 255)
end

-- Saving to a file
local pointer = marvel_rivals.get_world()  -- For example, dump the UWorld class
local dump = marvel_rivals.get_class_dump(pointer)

if dump == nil then
    engine.log("Class dump failed.", 255, 0, 0, 255)
    return
end

local lines = {}
for i, entry in ipairs(dump) do
    table.insert(lines, string.format("%s = 0x%X", entry.name, entry.offset))
end

local text = table.concat(lines, "\n")
fs.write_to_file("class_dump.txt", text)
engine.log("Class dump written to class_dump.txt", 0, 255, 0, 255)
Available Bone IDs
The following bone IDs are available for use with get_bone_position:

Head and Torso
bone_id_upper_head: Upper head bone

bone_id_head: Head bone

bone_id_neck: Neck bone

bone_id_chest: Chest bone

bone_id_stomach: Stomach bone

bone_id_pelvis: Pelvis bone

Left Arm
bone_id_left_shoulder: Left shoulder bone

bone_id_left_elbow: Left elbow bone

bone_id_left_hand: Left hand bone

Right Arm
bone_id_right_shoulder: Right shoulder bone

bone_id_right_elbow: Right elbow bone

bone_id_right_hand: Right hand bone

Left Leg
bone_id_left_hip: Left hip bone

bone_id_left_knee: Left knee bone

bone_id_left_foot: Left foot bone

Right Leg
bone_id_right_hip: Right hip bone

bone_id_right_knee: Right knee bone

bone_id_right_foot: Right foot bone

Counter-Strike 2
Functions for accessing game data, entities, bone positions, and game interfaces.

trace.cast
Signature: trace.cast(startx, starty, startz, endx, endy, endz)

Description: Performs a raycast from the start point to the end point, checking for collisions.

Parameters:

startx (number): X coordinate of the start point

starty (number): Y coordinate of the start point

startz (number): Z coordinate of the start point

endx (number): X coordinate of the end point

endy (number): Y coordinate of the end point

endz (number): Z coordinate of the end point

Returns:

boolean: true if the endpoint is hit/visible, false otherwise

Example:

Copy
local start_x, start_y, start_z = 100, 100, 100  -- Start position
local end_x, end_y, end_z = 200, 200, 200        -- End position

local hit = trace.cast(start_x, start_y, start_z, end_x, end_y, end_z)

if hit then
    engine.log("Line of sight exists between the points", 0, 255, 0, 255)
else
    engine.log("Line of sight is blocked", 255, 0, 0, 255)
end
cs2.get_interface
Signature: cs2.get_interface(module_name, interface_name)

Description: Retrieves a pointer to a game interface by name.

Parameters:

module_name (string): Name of the module containing the interface

interface_name (string): Name of the interface

Returns:

integer: Pointer to the requested interface

Example:

Copy
local client_interface = cs2.get_interface("client.dll", "VClient018")

if client_interface == 0 then
    engine.log("Failed to retrieve client interface", 255, 0, 0, 255)
    return
end

engine.log("Client interface: 0x" .. string.format("%X", client_interface), 0, 255, 0, 255)
cs2.get_cvar
Signature: cs2.get_cvar(cvar_name)

Description: Retrieves a pointer to a console variable (cvar) by name.

Parameters:

cvar_name (string): Name of the console variable

Returns:

integer: Pointer to the requested cvar

Example:

Copy
local sv_cheats = cs2.get_cvar("sv_cheats")

if sv_cheats == 0 then
    engine.log("Failed to retrieve sv_cheats cvar", 255, 0, 0, 255)
    return
end

engine.log("sv_cheats cvar: 0x" .. string.format("%X", sv_cheats), 0, 255, 0, 255)
cs2.get_entity_list
Signature: cs2.get_entity_list()

Description: Returns a pointer to the entity list.

Parameters: None

Returns:

integer: Pointer to the entity list

Example:

Copy
local entity_list = cs2.get_entity_list()

if entity_list == 0 then
    engine.log("Failed to retrieve entity list", 255, 0, 0, 255)
    return
end

engine.log("Entity list: 0x" .. string.format("%X", entity_list), 0, 255, 0, 255)
cs2.get_entity_system
Signature: cs2.get_entity_system()

Description: Returns a pointer to the entity system.

Parameters: None

Returns:

integer: Pointer to the entity system

Example:

Copy
local entity_system = cs2.get_entity_system()

if entity_system == 0 then
    engine.log("Failed to retrieve entity system", 255, 0, 0, 255)
    return
end

engine.log("Entity system: 0x" .. string.format("%X", entity_system), 0, 255, 0, 255)
cs2.get_highest_entity_index
Signature: cs2.get_highest_entity_index()

Description: Returns the highest entity index currently in use.

Parameters: None

Returns:

integer: The highest entity index

Example:

Copy
local highest_index = cs2.get_highest_entity_index()
engine.log("Highest entity index: " .. highest_index, 0, 255, 0, 255)
cs2.get_global_vars
Signature: cs2.get_global_vars()

Description: Returns a pointer to the global variables.

Parameters: None

Returns:

integer: Pointer to the global variables

Example:

Copy
local global_vars = cs2.get_global_vars()

if global_vars == 0 then
    engine.log("Failed to retrieve global vars", 255, 0, 0, 255)
    return
end

engine.log("Global vars: 0x" .. string.format("%X", global_vars), 0, 255, 0, 255)
cs2.get_game_rules
Signature: cs2.get_game_rules()

Description: Returns a pointer to the game rules.

Parameters: None

Returns:

integer: Pointer to the game rules

Example:

Copy
local game_rules = cs2.get_game_rules()

if game_rules == 0 then
    engine.log("Failed to retrieve game rules", 255, 0, 0, 255)
    return
end

engine.log("Game rules: 0x" .. string.format("%X", game_rules), 0, 255, 0, 255)
cs2.get_planted_c4
Signature: cs2.get_planted_c4()

Description: Returns a pointer to the planted C4 bomb, if one exists.

Parameters: None

Returns:

integer: Pointer to the planted C4 bomb, or 0 if no bomb is planted

Example:

Copy
local c4 = cs2.get_planted_c4()

if c4 == 0 then
    engine.log("No C4 is currently planted", 255, 255, 0, 255)
    return
end

engine.log("Planted C4: 0x" .. string.format("%X", c4), 0, 255, 0, 255)
cs2.get_view_matrix
Signature: cs2.get_view_matrix()

Description: Returns a pointer to the view matrix, which can be used for world-to-screen transformations.

Parameters: None

Returns:

integer: Pointer to the view matrix

Example:

Copy
local view_matrix = cs2.get_view_matrix()

if view_matrix == 0 then
    engine.log("Failed to retrieve view matrix", 255, 0, 0, 255)
    return
end

engine.log("View matrix: 0x" .. string.format("%X", view_matrix), 0, 255, 0, 255)
cs2.world_to_screen
Signature: cs2.world_to_screen(x, y, z)

Description: Converts 3D world coordinates to 2D screen coordinates.

Parameters:

x (number): X coordinate in world space

y (number): Y coordinate in world space

z (number): Z coordinate in world space

Returns:

x (number): X coordinate in screen space

y (number): Y coordinate in screen space

Returns nil if the conversion fails (e.g., if the point is behind the camera).

Example:

Copy
local world_x, world_y, world_z = 100, 200, 300
local screen_x, screen_y = cs2.world_to_screen(world_x, world_y, world_z)

if screen_x and screen_y then
    engine.log("World (" .. world_x .. ", " .. world_y .. ", " .. world_z .. ") -> Screen (" .. screen_x .. ", " .. screen_y .. ")", 0, 255, 0, 255)
    
    -- Draw a marker at the screen position
    render.draw_circle(screen_x, screen_y, 5, 255, 0, 0, 255, 1, true)
else
    engine.log("Point is not visible on screen", 255, 0, 0, 255)
end
cs2.get_bone_position
Signature: cs2.get_bone_position(bone_array, bone_id)

Description: Returns the world position of the specified bone.

Parameters:

bone_array (integer): Pointer to the bone array

bone_id (integer): ID of the bone to get the position of

Returns:

x (number): X coordinate of the bone in world space

y (number): Y coordinate of the bone in world space

z (number): Z coordinate of the bone in world space

Returns nil if the function fails.

Example:

Copy
local local_player = cs2.get_local_player()

if not local_player or local_player.bone_array == 0 then
    engine.log("Local player bone array not available", 255, 0, 0, 255)
    return
end

-- Head bone ID is typically 6 in CS2
local head_bone_id = 6
local head_x, head_y, head_z = cs2.get_bone_position(local_player.bone_array, head_bone_id)

if head_x then
    engine.log("Head position: (" .. head_x .. ", " .. head_y .. ", " .. head_z .. ")", 0, 255, 0, 255)
    
    -- Convert to screen coordinates
    local screen_x, screen_y = cs2.world_to_screen(head_x, head_y, head_z)
    if screen_x and screen_y then
        render.draw_circle(screen_x, screen_y, 5, 255, 0, 0, 255, 1, true)
    end
else
    engine.log("Failed to get head bone position", 255, 0, 0, 255)
end
cs2.get_player_list
Signature: cs2.get_player_list()

Description: Returns a table containing information about all players in the game.

Parameters: None

Returns:

table: A table of player data, where each entry contains:

controller (integer): Pointer to the player's controller

pawn (integer): Pointer to the player's pawn

clipping_weapon (integer): Pointer to the player's current weapon

bone_array (integer): Pointer to the player's bone array

is_teammate (boolean): Whether the player is on the same team as the local player

Returns nil if the player list is not available.

Example:

Copy
local players = cs2.get_player_list()

if players == nil then
    engine.log("No player list found.", 255, 0, 0, 255)
    return
end

for index, player in pairs(players) do
    engine.log("Player " .. index, 255, 255, 0, 255)
    engine.log("  controller = 0x" .. string.format("%X", player.controller), 200, 200, 200, 255)
    engine.log("  pawn = 0x" .. string.format("%X", player.pawn), 200, 200, 200, 255)
    engine.log("  is_teammate = " .. tostring(player.is_teammate), 200, 200, 200, 255)
    
    -- Skip drawing for teammates if desired
    if not player.is_teammate and player.bone_array ~= 0 then
        -- Example: Draw head ESP
        local head_x, head_y, head_z = cs2.get_bone_position(player.bone_array, 6) -- Head bone
        if head_x then
            local screen_x, screen_y = cs2.world_to_screen(head_x, head_y, head_z)
            if screen_x and screen_y then
                render.draw_circle(screen_x, screen_y, 5, 255, 0, 0, 255, 1, true)
            end
        end
    end
end
cs2.get_local_player
Signature: cs2.get_local_player()

Description: Returns information about the local player.

Parameters: None

Returns:

table: A table containing the following fields:

controller (integer): Pointer to the local player's controller

pawn (integer): Pointer to the local player's pawn

clipping_weapon (integer): Pointer to the local player's current weapon

bone_array (integer): Pointer to the local player's bone array

Returns nil if the local player information is not available.

Example:

Copy
local local_player = cs2.get_local_player()

if local_player == nil then
    engine.log("Local player not available.", 255, 0, 0, 255)
    return
end

engine.log("Local Player Info", 0, 255, 0, 255)
engine.log("  controller = 0x" .. string.format("%X", local_player.controller), 200, 200, 200, 255)
engine.log("  pawn = 0x" .. string.format("%X", local_player.pawn), 200, 200, 200, 255)
engine.log("  clipping_weapon = 0x" .. string.format("%X", local_player.clipping_weapon), 200, 200, 200, 255)
engine.log("  bone_array = 0x" .. string.format("%X", local_player.bone_array), 200, 200, 200, 255)
cs2.get_schema_dump
Signature: cs2.get_schema_dump()

Description: Returns a table containing the dumped schema fields for Counter-Strike 2. Each entry in the table includes the field name and associated memory offset.

Parameters: None

Returns:

table: A table of schema fields with the following structure:

Copy
{
    [1] = { name = "CCSPlayer_MovementServices::m_bInStuckTest", offset = 0x25A },
    [2] = { name = "CCSPlayer_MovementServices::m_flStuckCheckTime", offset = 0x268 },
    [3] = { name = "CCSPlayer_MovementServices::m_nTraceCount", offset = 0x468 },
    ...
}
Returns nil if no schema dump is available (e.g., if the process is not attached).

Example:

Copy
-- Basic usage
local dump = cs2.get_schema_dump()

if dump == nil then
    engine.log("Schema dump not available.", 255, 0, 0, 255)
    return
end

engine.log("Schema dump contains " .. #dump .. " entries", 0, 255, 0, 255)

-- Print the first 5 entries as a sample
for i = 1, 5 do
    if dump[i] then
        engine.log(string.format("%s = 0x%X", dump[i].name, dump[i].offset), 0, 255, 0, 255)
    end
end

-- Save to file
local dump = cs2.get_schema_dump()

if dump == nil then
    engine.log("No schema dump available or process not attached.", 255, 0, 0, 255)
    return
end

local lines = {}

for i, entry in ipairs(dump) do
    table.insert(lines, string.format("%s = 0x%X", entry.name, entry.offset))
end

local text = table.concat(lines, "\n")

fs.write_to_file("offset_dump.txt", text)
engine.log("Offset dump written to offset_dump.txt", 0, 255, 0, 255)
Valorant
Functions for accessing game class structures and metadata.

valorant.get_class_dump
Signature: valorant.get_class_dump(pointer)

Description: Returns a table containing the class fields for the specified class pointer in Valorant. This is useful for reverse engineering or understanding the internal structure of class objects at runtime.

Parameters:

pointer (integer): The memory address of the class you want to dump.

Returns:

table: A table of class fields with the following structure:

Copy
{
    [1] = { name = "PlayerCameraManager::CameraCachePrivate", offset = 0x120 },
    [2] = { name = "Character::Mesh", offset = 0x154 },
    ...
}
Returns nil and logs an error if:

Argument is missing or not an integer

Pointer is null

Dump is empty

Example:

Copy
-- Basic usage
local pointer = 0x1A2B3C4D  -- Replace with actual class pointer (e.g., uworld)
local dump = valorant.get_class_dump(pointer)

if dump == nil then
    engine.log("Class dump failed.", 255, 0, 0, 255)
    return
end

for i, entry in ipairs(dump) do
    engine.log(string.format("%s = 0x%X", entry.name, entry.offset), 0, 255, 0, 255)
end

-- Saving to a file
local pointer = 0x1A2B3C4D  -- Replace with actual class pointer
local dump = valorant.get_class_dump(pointer)

if dump == nil then
    engine.log("Class dump failed.", 255, 0, 0, 255)
    return
end

local lines = {}
for i, entry in ipairs(dump) do
    table.insert(lines, string.format("%s = 0x%X", entry.name, entry.offset))
end

local text = table.concat(lines, "\n")
fs.write_to_file("class_dump.txt", text)
engine.log("Class dump written to class_dump.txt", 0, 255, 0, 255)
Universal API
Supported Games & Functions
Standardized access to cross-game runtime data and features.

Universal API functions are restricted to users with an active Universal Lua API subscription.
These functions will not work with any other subscription.

Fortnite
fortnite.get_player_name
Signature: fortnite.get_player_name(address)

Description: Retrieves the decrypted player name from a known memory address.

Parameters:

address (integer): The memory address pointing to the name structure

Returns:

string: Decrypted player name

Example:

Copy
local name = fortnite.get_player_name(address)
engine.log("Player name: " .. name, 0, 255, 0, 255)
Rust
rust.get_transform_position
Signature: rust.get_transform_position(address)

Description: Retrieves world-space transform position from a transform address.

Parameters:

address (integer): Pointer to the transform component

Returns:

x (number): X coordinate in world space

y (number): Y coordinate in world space

z (number): Z coordinate in world space

Example:

Copy
local x, y, z = rust.get_transform_position(address)
engine.log("Transform position: (" .. x .. ", " .. y .. ", " .. z .. ")", 0, 255, 0, 255)
PUBG
The init_decrypt function for PUBG may have been a bait set by PUBG developers or anti-cheat. Do NOT use this function in production or live environments. We are currently testing the function (or just using the universal API loaded on PUBG) to see how it behaves. Use at your own risk.

pubg.init_decrypt
Signature: pubg.init_decrypt(offset)

Description: Initializes the decryption system with a given offset.

Parameters:

offset (integer): Integer offset required for decryption initialization

Returns:

boolean: true if successful, false otherwise

pubg.xe_decrypt
Signature: pubg.xe_decrypt(address)

Description: Decrypts a given encrypted memory address.

Parameters:

address (integer): Encrypted memory address as an integer

Returns:

integer: Decrypted memory address

Process Functions
Universal API functions are restricted to users with an active Universal Lua API subscription.
These functions will not work with any other subscription.

proc.attach_by_pid
Signature: proc.attach_by_pid(process_id, has_corrupt_cr3)

Description: Attach to a process using its PID.

Parameters:

process_id (integer): The PID of the process to attach to

has_corrupt_cr3 (boolean, optional): Set to true for games protected by Easy Anti-Cheat to resolve corrupted CR3

Returns:

boolean: true if attached successfully, false otherwise

Example:

Copy
local process_id = 1234  -- Replace with actual PID
if proc.attach_by_pid(process_id) then
    engine.log("Successfully attached to process " .. process_id, 0, 255, 0, 255)
else
    engine.log("Failed to attach to process " .. process_id, 255, 0, 0, 255)
end
proc.attach_by_name
Signature: proc.attach_by_name(process_name, has_corrupt_cr3)

Description: Attach to a process using its name.

Parameters:

process_name (string): The name of the process to attach to (e.g., "notepad.exe")

has_corrupt_cr3 (boolean, optional): Set to true for games protected by Easy Anti-Cheat to resolve corrupted CR3

Returns:

boolean: true if attached successfully, false otherwise

Example:

Copy
if not proc.attach_by_name("notepad.exe") then
    engine.log("Failed to attach to Notepad!", 255, 0, 0, 255)
    return
end
engine.log("Successfully attached to Notepad!", 0, 255, 0, 255)
proc.attach_by_window
Signature: proc.attach_by_window(window_class, window_name, has_corrupt_cr3)

Description: Attach to a process using its window class and window name.

Parameters:

window_class (string): The window class

window_name (string): The window name

has_corrupt_cr3 (boolean, optional): Set to true for games protected by Easy Anti-Cheat to resolve corrupted CR3

Returns:

boolean: true if attached successfully, false otherwise

Example:

Copy
if not proc.attach_by_window("Notepad", "Untitled - Notepad") then
    engine.log("Failed to attach to Notepad window!", 255, 0, 0, 255)
    return
end
engine.log("Successfully attached to Notepad window!", 0, 255, 0, 255)
proc.is_attached
Signature: proc.is_attached()

Description: Check if a process is currently attached.

Parameters: None

Returns:

boolean: true if a process is attached, false otherwise

Example:

Copy
if proc.is_attached() then
    engine.log("Process is attached", 0, 255, 0, 255)
else
    engine.log("No process is attached", 255, 0, 0, 255)
end
Complete Example
Copy
-- Attempt to attach to Notepad by process name
if not proc.attach_by_name("notepad.exe") then
    engine.log("Failed to attach to Notepad!", 255, 0, 0, 255)
    return
end
engine.log("Successfully attached to Notepad!", 0, 255, 0, 255)

-- Get the base address of Notepad
local base_address = proc.base_address()
if base_address == nil then
    engine.log("Failed to get Notepad base address!", 255, 0, 0, 255)
    return
end
engine.log("Base Address: " .. string.format("0x%X", base_address), 255, 255, 255, 255)

-- Define the offset for e_lfanew in the DOS header
local e_lfanew_offset = 0x3C
-- Read the e_lfanew value (DWORD) from the PE header
local e_lfanew = proc.read_int32(base_address + e_lfanew_offset)
if e_lfanew == nil then
    engine.log("Failed to read e_lfanew!", 255, 0, 0, 255)
    return
end
engine.log("e_lfanew: " .. e_lfanew, 0, 255, 0, 255)
Notes
These functions do not create OpenProcess handles, they only set up process interaction.

If an invalid argument is provided, an error is thrown.

If the process cannot be found or attached, the function returns false.

Information
Universal API Information
Supported Anti-Cheats
The Universal Lua API product fully bypasses the following anti-cheat systems:

Easy Anti-Cheat (CR3 Shuffle also supported)

BattleEye

Neac Protect

Valve Anti-Cheat (VAC)

nProtect Game Guard

ACE

EA Anti-Cheat

PAC (VALVE's Chinese Perfect World Arena)

Some anti-cheats have not been tested but are likely compatible. Please inquire if you need specific anti-cheat compatibility testing.

Not Allowed/Supported
Riot's Vanguard Anti-Cheat

Face-IT